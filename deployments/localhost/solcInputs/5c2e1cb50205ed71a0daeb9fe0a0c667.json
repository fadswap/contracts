{
  "language": "Solidity",
  "sources": {
    "contracts/farm/Reward.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"../Swap.sol\";\r\nimport \"../lib/SwapConstants.sol\";\r\nimport \"../lib/Voting.sol\";\r\nimport \"../lib/FADERC20.sol\";\r\nimport \"../helpers/AbstractReward.sol\";\r\n\r\n/*\r\n* Farming rewards contract\r\n*/\r\ncontract Reward is AbstractReward {\r\n    using Vote for Vote.Data;\r\n    using Voting for Voting.Data;\r\n    using FADERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    event Staked(address indexed user, uint256 amount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event FeeVoteUpdate(address indexed user, uint256 fee, bool isDefault, uint256 amount);\r\n    event SlippageFeeVoteUpdate(address indexed user, uint256 slippageFee, bool isDefault, uint256 amount);\r\n    event DecayPeriodVoteUpdate(address indexed user, uint256 decayPeriod, bool isDefault, uint256 amount);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    Swap public immutable swap;\r\n    IGovernanceFactory public immutable governanceFactory;\r\n\r\n    Voting.Data private _fee;\r\n    Voting.Data private _slippageFee;\r\n    Voting.Data private _decayPeriod;\r\n\r\n    constructor(Swap _swap, IERC20 _gift, uint256 _duration, address _rewardDistributor, uint256 scale)\r\n    {\r\n      swap = _swap;\r\n      governanceFactory = _swap.governanceFactory();\r\n      addRewardGift(_gift, _duration, _rewardDistributor, scale);\r\n    }\r\n\r\n    function name() external view returns(string memory)\r\n    {\r\n      return string(abi.encodePacked(\"Farming: \", swap.name()));\r\n    }\r\n\r\n    function symbol() external view returns(string memory)\r\n    {\r\n      return string(abi.encodePacked(\"farm: \", swap.symbol()));\r\n    }\r\n\r\n    function decimals() external view returns(uint8)\r\n    {\r\n      return swap.decimals();\r\n    }\r\n\r\n    /** Stakes `amount` of tokens into farm */\r\n    function stake(uint256 amount) public updateAccountReward(msg.sender)\r\n    {\r\n      require(amount > 0, \"Can't Stake 0\");\r\n      swap.transferFrom(msg.sender, address(this), amount);\r\n      _mint(msg.sender, amount);\r\n\r\n      emit Staked(msg.sender, amount);\r\n      emit Transfer(address(0), msg.sender, amount);\r\n    }\r\n\r\n    /** Withdraws `amount` of tokens from farm */\r\n    function withdraw(uint256 amount) public updateAccountReward(msg.sender)\r\n    {\r\n      require(amount > 0, \"Can't Withdraw 0\");\r\n      _burn(msg.sender, amount);\r\n      swap.transfer(msg.sender, amount);\r\n\r\n      emit Withdrawn(msg.sender, amount);\r\n      emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n\r\n    /** Withdraws all staked funds and rewards */\r\n    function exit() external\r\n    {\r\n      withdraw(balanceOf(msg.sender));\r\n      getAllReward();\r\n    }\r\n\r\n    function getFee() public view returns(uint256)\r\n    {\r\n      return _fee.result;\r\n    } \r\n\r\n    function getSlippageFee() public view returns(uint256)\r\n    {\r\n      return _slippageFee.result;\r\n    } \r\n\r\n    function getDecayPeriod() public view returns(uint256)\r\n    {\r\n      return _decayPeriod.result;\r\n    } \r\n\r\n    function getFeeVotes(address user) external view returns(uint256)\r\n    {\r\n      return _fee.votes[user].get(governanceFactory.getDefaultFee);\r\n    }\r\n\r\n    function getSlippageFeeVotes(address user) external view returns(uint256)\r\n    {\r\n      return _slippageFee.votes[user].get(governanceFactory.getDefaultSlippageFee);\r\n    }\r\n\r\n    function getDecayPeriodVotes(address user) external view returns(uint256)\r\n    {\r\n      return _slippageFee.votes[user].get(governanceFactory.getDefaultDecayPeriod);\r\n    }\r\n\r\n    function voteFee(uint256 vote) external\r\n    {\r\n      require(vote <= SwapConstants._MAX_FEE, \"Fee Vote Is Too High\");\r\n      _fee.updateVote(\r\n        msg.sender, \r\n        _fee.votes[msg.sender], \r\n        Vote.init(vote), \r\n        balanceOf(msg.sender), \r\n        totalSupply(),\r\n        governanceFactory.getDefaultFee(), \r\n        _emitVoteFeeUpdate\r\n      );\r\n\r\n      _vote(_fee, swap.voteFee, swap.discardFeeVote);\r\n    }\r\n\r\n    function voteSlippageFee(uint256 vote) external\r\n    {\r\n      require(vote <= SwapConstants._MAX_SLIPPAGE_FEE, \"Slippage Fee Vote Is Too High\");\r\n      _slippageFee.updateVote(\r\n        msg.sender, \r\n        _slippageFee.votes[msg.sender], \r\n        Vote.init(vote), \r\n        balanceOf(msg.sender), \r\n        totalSupply(),\r\n        governanceFactory.getDefaultSlippageFee(), \r\n        _emitVoteSlippageFeeUpdate\r\n      );\r\n\r\n      _vote(_slippageFee, swap.voteSlippageFee, swap.discardSlippageFeeVote);\r\n    }\r\n\r\n    function voteDecayPeriod(uint256 vote) external\r\n    {\r\n      require(vote <= SwapConstants._MAX_DECAY_PERIOD, \"Decay Period Vote Is Too High\");\r\n      require(vote >= SwapConstants._MIN_DECAY_PERIOD, \"Decay Period Vote Is Too Low\");\r\n      _decayPeriod.updateVote(\r\n        msg.sender, \r\n        _decayPeriod.votes[msg.sender], \r\n        Vote.init(vote), \r\n        balanceOf(msg.sender), \r\n        totalSupply(),\r\n        governanceFactory.getDefaultDecayPeriod(), \r\n        _emitVoteDecayPeriodUpdate\r\n      );\r\n\r\n      _vote(_decayPeriod, swap.voteDecayPeriod, swap.discardDecayPeriodVote);\r\n    }\r\n\r\n    function discardFeeVote() external\r\n    {\r\n      _fee.updateVote(\r\n        msg.sender, \r\n        _fee.votes[msg.sender], \r\n        Vote.init(), \r\n        balanceOf(msg.sender), \r\n        totalSupply(),\r\n        governanceFactory.getDefaultFee(),\r\n        _emitVoteFeeUpdate\r\n      );\r\n    }\r\n\r\n    function discardSlippageFeeVote() external\r\n    {\r\n      _slippageFee.updateVote(\r\n        msg.sender, \r\n        _slippageFee.votes[msg.sender], \r\n        Vote.init(), \r\n        balanceOf(msg.sender), \r\n        totalSupply(),\r\n        governanceFactory.getDefaultSlippageFee(),\r\n        _emitVoteSlippageFeeUpdate\r\n      );\r\n    }\r\n\r\n    function discardDecayPeriodVote() external\r\n    {\r\n      _slippageFee.updateVote(\r\n        msg.sender, \r\n        _slippageFee.votes[msg.sender], \r\n        Vote.init(), \r\n        balanceOf(msg.sender), \r\n        totalSupply(),\r\n        governanceFactory.getDefaultSlippageFee(),\r\n        _emitVoteSlippageFeeUpdate\r\n      );\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal override\r\n    {\r\n      super._mint(account, amount);\r\n\r\n      uint256 newBalance = balanceOf(account);\r\n      _updateVotes(account, newBalance.sub(amount), newBalance, totalSupply());\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal override\r\n    {\r\n      super._burn(account, amount);\r\n\r\n      uint256 newBalance = balanceOf(account);\r\n      _updateVotes(account, newBalance.add(amount), newBalance, totalSupply());\r\n    }\r\n\r\n    function _updateVotes(address account, uint256 balance, uint256 newBalance, uint256 newTotalSupply) private\r\n    {\r\n      _fee.updateBalance(\r\n        account, \r\n        _fee.votes[account], \r\n        balance, \r\n        newBalance, \r\n        newTotalSupply, \r\n        governanceFactory.getDefaultFee(), \r\n        _emitVoteFeeUpdate\r\n      );\r\n\r\n      _vote(_fee, swap.voteFee, swap.discardFeeVote);\r\n\r\n      _slippageFee.updateBalance(\r\n        account, \r\n        _slippageFee.votes[account], \r\n        balance, \r\n        newBalance, \r\n        newTotalSupply, \r\n        governanceFactory.getDefaultSlippageFee(), \r\n        _emitVoteSlippageFeeUpdate\r\n      );\r\n\r\n      _vote(_slippageFee, swap.voteSlippageFee, swap.discardSlippageFeeVote);\r\n\r\n      _decayPeriod.updateBalance(\r\n        account, \r\n        _decayPeriod.votes[account], \r\n        balance, \r\n        newBalance, \r\n        newTotalSupply, \r\n        governanceFactory.getDefaultDecayPeriod(), \r\n        _emitVoteDecayPeriodUpdate\r\n      );\r\n\r\n      _vote(_decayPeriod, swap.voteDecayPeriod, swap.discardDecayPeriodVote);\r\n    }\r\n\r\n    function _vote(Voting.Data storage votingData, function(uint256) external vote, function() external discardVote) private {\r\n      if(votingData.weightedSum == 0){\r\n        discardVote();\r\n      } else {\r\n        vote(votingData.result);\r\n      }\r\n    }\r\n\r\n    function _emitVoteFeeUpdate(address user, uint256 fee, bool isDefault, uint256 amount) private\r\n    {\r\n      emit FeeVoteUpdate(user, fee, isDefault, amount);\r\n    }\r\n\r\n    function _emitVoteSlippageFeeUpdate(address user, uint256 slippageFee, bool isDefault, uint256 amount) private\r\n    {\r\n      emit SlippageFeeVoteUpdate(user, slippageFee, isDefault, amount);\r\n    }\r\n\r\n    function _emitVoteDecayPeriodUpdate(address user, uint256 decayPeriod, bool isDefault, uint256 amount) private\r\n    {\r\n      emit DecayPeriodVoteUpdate(user, decayPeriod, isDefault, amount);\r\n    }\r\n\r\n    /** Allows contract owner to withdraw funds that was send to contract by mistake */\r\n  function rescueFunds(IERC20 token, uint256 amount)\r\n    external\r\n    onlyOwner\r\n  {\r\n    for(uint256 i = 0; i < tokenRewards.length; i++) {\r\n      require(token != tokenRewards[i].gift, \"Can't Rescue Gift\");\r\n    }\r\n\r\n    token.fadTransfer(payable(msg.sender), amount);\r\n\r\n    if(token == swap) {\r\n      require(token.getBalanceOf(address(this)) == totalSupply(), \"Can't Withdraw Staked Tokens\");\r\n    }\r\n  }\r\n}"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Swap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./interfaces/IFeeCollector.sol\";\r\nimport \"./lib/FADERC20.sol\";\r\nimport \"./lib/SQRT.sol\";\r\nimport \"./lib/VirtualBalance.sol\";\r\nimport \"./governance/Governance.sol\";\r\n\r\ncontract Swap is Governance {\r\n  using SQRT for uint256;\r\n  using SafeMath for uint256;\r\n  using FADERC20 for IERC20;\r\n  using VirtualBalance for VirtualBalance.Data;\r\n\r\n  struct Balances {\r\n    uint256 src;\r\n    uint256 dst;\r\n  }\r\n\r\n  struct Volumes {\r\n    uint128 confirmed;\r\n    uint128 result;\r\n  }\r\n  \r\n  struct Fees {\r\n    uint256 fee;\r\n    uint256 slippageFee;\r\n  }\r\n\r\n  event Error(string reason);\r\n\r\n  event Deposited(\r\n    address indexed sender,\r\n    address indexed receiver,\r\n    uint256 share,\r\n    uint256 token0Amount,\r\n    uint256 token1Amount\r\n  );\r\n\r\n  event Withdrawn(\r\n    address indexed sender,\r\n    address indexed receiver,\r\n    uint256 share,\r\n    uint256 token0Amount,\r\n    uint256 token1Amount\r\n  );\r\n\r\n  event Swapped(\r\n    address indexed sender,\r\n    address indexed receiver,\r\n    address indexed srcToken,\r\n    address dstToken,\r\n    uint256 amount,\r\n    uint256 result,\r\n    uint256 srcBalanceAdded,\r\n    uint256 dstBalanceRemoved,\r\n    address referral\r\n  );\r\n\r\n  event Sync(\r\n    uint256 srcBalance,\r\n    uint256 dstBalance,\r\n    uint256 fee,\r\n    uint256 slippageFee,\r\n    uint256 referralShare,\r\n    uint256 governanceShare\r\n  );\r\n\r\n  uint256 private constant _BASE_SUPPLY = 1000; // Total supply on first deposit\r\n\r\n  IERC20 public immutable token0;\r\n  IERC20 public immutable token1;\r\n  mapping(IERC20 => Volumes) public volumes;\r\n  mapping(IERC20 => VirtualBalance.Data) public virtualBalanceToAdd;\r\n  mapping(IERC20 => VirtualBalance.Data) public virtualBalanceToRemove;\r\n\r\n  modifier whenNotShutdown {\r\n    require(governanceFactory.isActive(), \"Swap: Factory Is Shutdown\");\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    IERC20 _token0,\r\n    IERC20 _token1,\r\n    string memory name,\r\n    string memory symbol,\r\n    IGovernanceFactory _governanceFactory\r\n  ) \r\n    ERC20(name, symbol)\r\n    Governance(_governanceFactory)\r\n  {\r\n    require(bytes(name).length > 0, \"Swap: Name Is Empty\");\r\n    require(bytes(symbol).length > 0, \"Swap: Symbol Is Empty\");\r\n    require(_token0 != _token1, \"Swap: Two Tokens Is Same\");\r\n    token0 = _token0;\r\n    token1 = _token1;\r\n  }\r\n\r\n  /** Returns pair of tokens as [token0, token1] */\r\n  function getTokens()\r\n    external\r\n    view\r\n    returns(IERC20[] memory tokens)\r\n  {\r\n    tokens = new IERC20[](2);\r\n    tokens[0] = token0;\r\n    tokens[1] = token1;\r\n  }\r\n\r\n  function getToken(uint256 position)\r\n    external\r\n    view\r\n    returns(IERC20)\r\n  {\r\n    if(position == 0 ) {\r\n      return token0;\r\n    } else if(position == 1){\r\n      return token1;\r\n    } else {\r\n      revert(\"Swap: Pool Have Only Two Tokens\");\r\n    }\r\n  }\r\n\r\n  function getBalanceToAdd(IERC20 token)\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    uint256 balance = token.getBalanceOf(address(this));\r\n    return Math.max(virtualBalanceToAdd[token].current(getDecayPeriod(), balance), balance);\r\n  }\r\n\r\n  function getBalanceToRemove(IERC20 token)\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    uint256 balance = token.getBalanceOf(address(this));\r\n    return Math.min(virtualBalanceToRemove[token].current(getDecayPeriod(), balance), balance);\r\n  }\r\n\r\n  /** Returns how many `dst` tokens will be returned for `amount` of `src` tokens */\r\n  function getQuote(IERC20 src, IERC20 dst, uint256 amount)\r\n    external\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _getQuote(src, dst, amount, getBalanceToAdd(src), getBalanceToRemove(dst), getFee(), getSlippageFee());\r\n  }\r\n\r\n  function deposit(uint256[2] memory maxAmounts, uint256[2] memory minAmounts)\r\n    external\r\n    payable\r\n    returns(uint256 fairSupply, uint256[2] memory receivedAmounts)\r\n  {\r\n    return depositFor(maxAmounts, minAmounts, msg.sender);\r\n  }\r\n\r\n  function depositFor(uint256[2] memory maxAmounts, uint256[2] memory minAmounts, address target)\r\n    public\r\n    payable\r\n    nonReentrant\r\n    returns(uint256 fairSupply, uint256[2] memory receivedAmounts)\r\n  {\r\n    IERC20[2] memory _tokens = [token0, token1];\r\n    require(msg.value == (_tokens[0].isBNB() ? maxAmounts[0] : (_tokens[1].isBNB() ? maxAmounts[1] : 0)), \"Swap: Wrong Value Usage\");\r\n    uint256 totalSupply = totalSupply();\r\n    if(totalSupply == 0) {\r\n      fairSupply = _BASE_SUPPLY.mul(99);\r\n      _mint(address(this), _BASE_SUPPLY); // Donate up to 1%\r\n\r\n      for(uint i = 0; i < maxAmounts.length; i++) {\r\n        fairSupply = Math.max(fairSupply, maxAmounts[i]);\r\n        require(maxAmounts[i] > 0, \"Swap: Amount Is Zero\");\r\n        require(maxAmounts[i] >= minAmounts[i], \"Swap: Min Amount Not Reached\");\r\n        _tokens[i].fadTransferFrom(payable(msg.sender), address(this), maxAmounts[i]);\r\n        receivedAmounts[i] = maxAmounts[i];\r\n      }\r\n    } else {\r\n      uint256[2] memory realBalances;\r\n      for(uint i = 0; i < realBalances.length; i++) {\r\n        realBalances[i] = _tokens[i].getBalanceOf(address(this)).sub(_tokens[i].isBNB() ? msg.value : 0);\r\n      }\r\n\r\n      fairSupply = type(uint256).max;\r\n      for(uint i = 0; i < maxAmounts.length; i++) {\r\n        fairSupply = Math.min(fairSupply, totalSupply.mul(maxAmounts[i]).div(realBalances[i]));\r\n      }\r\n\r\n      uint256 fairSupplyCached = fairSupply; \r\n      for(uint i = 0; i < maxAmounts.length; i++) {\r\n        require(maxAmounts[i] > 0, \"Swap: Amount Is Zero\");\r\n        uint256 amount = realBalances[i].mul(fairSupplyCached).add(totalSupply - 1).div(totalSupply);\r\n        require(amount >= minAmounts[i], \"Swap: Min Amount Not Reached\");\r\n        _tokens[i].fadTransferFrom(payable(msg.sender), address(this), amount);\r\n        receivedAmounts[i] = _tokens[i].getBalanceOf(address(this)).sub(realBalances[i]);\r\n        fairSupply = Math.min(fairSupply, totalSupply.mul(receivedAmounts[i]).div(realBalances[i]));\r\n      }\r\n\r\n      uint256 _decayPeriod = getDecayPeriod(); // gas saving\r\n      for(uint i = 0; i < maxAmounts.length; i++) {\r\n        virtualBalanceToRemove[_tokens[i]].scale(_decayPeriod, realBalances[i], totalSupply.add(fairSupply), totalSupply);\r\n        virtualBalanceToAdd[_tokens[i]].scale(_decayPeriod, realBalances[i], totalSupply.add(fairSupply), totalSupply);\r\n      }\r\n    }\r\n      \r\n    require(fairSupply > 0, \"Swap: Result Is Not Enough\");\r\n    _mint(target, fairSupply);\r\n\r\n    emit Deposited(msg.sender, target, fairSupply, receivedAmounts[0], receivedAmounts[1]);\r\n  }\r\n\r\n  function withdraw(uint256 amount, uint256[] memory minReturns)\r\n    external\r\n    returns(uint256[2] memory withdrawnAmounts)\r\n  {\r\n    return withdrawFor(amount, minReturns, payable(msg.sender));\r\n  }\r\n\r\n  /** Withdraws funds from the liquidity pool */\r\n  function withdrawFor(uint256 amount, uint256[] memory minReturns, address payable target)\r\n    public\r\n    nonReentrant\r\n    returns(uint256[2] memory withdrawnAmounts)\r\n  {\r\n    IERC20[2] memory _tokens = [token0, token1];\r\n    uint256 totalSupply = totalSupply();\r\n    uint256 _decayPeriod = getDecayPeriod(); // gas saving\r\n    _burn(msg.sender, amount);\r\n\r\n    for(uint i = 0; i < _tokens.length; i++) {\r\n      IERC20 token = _tokens[i];\r\n      uint256 preBalance = token.getBalanceOf(address(this));\r\n      uint256 value = preBalance.mul(amount).div(totalSupply);\r\n      token.fadTransfer(target, value);\r\n      withdrawnAmounts[i] = value;\r\n      require(i >= minReturns.length || value >= minReturns[i], \"Swap: Result Is Not Enough\");\r\n      virtualBalanceToRemove[token].scale(_decayPeriod, preBalance, totalSupply.add(amount), totalSupply);\r\n      virtualBalanceToAdd[token].scale(_decayPeriod, preBalance, totalSupply.add(amount), totalSupply);\r\n    }\r\n\r\n    emit Withdrawn(msg.sender, target, amount, withdrawnAmounts[0], withdrawnAmounts[1]);\r\n  }\r\n\r\n  function swap(IERC20 src, IERC20 dst, uint256 amount, uint256 minReturn, address referral)\r\n    external\r\n    payable\r\n    returns(uint256 result)\r\n  {\r\n    return swapFor(src, dst, amount, minReturn, referral, payable(msg.sender));\r\n  }\r\n\r\n  function swapFor(IERC20 src, IERC20 dst, uint256 amount, uint256 minReturn, address referral, address payable receiver)\r\n    public\r\n    payable\r\n    nonReentrant\r\n    whenNotShutdown\r\n    returns(uint256 result)\r\n  {\r\n    require(msg.value == (src.isBNB() ? amount : 0), \"Swap: Wrong Value\");\r\n    Balances memory balances = Balances({\r\n      src: src.getBalanceOf(address(this)).sub(src.isBNB() ? msg.value : 0),\r\n      dst: dst.getBalanceOf(address(this))\r\n    });\r\n\r\n    uint256 confirmed;\r\n    Balances memory virtualBalances;\r\n    Fees memory fees = Fees({\r\n      fee: getFee(),\r\n      slippageFee: getSlippageFee()\r\n    });\r\n\r\n    (confirmed, result, virtualBalances) = _doTransfers(src, dst, amount, minReturn, receiver, balances, fees);\r\n    emit Swapped(msg.sender, receiver, address(src), address(dst), confirmed, result, virtualBalances.src, virtualBalances.dst, referral);\r\n    \r\n    _mintRewards(confirmed, result, referral, balances, fees);\r\n\r\n    // Overflow of uint128 is desired\r\n    volumes[src].confirmed += uint128(confirmed);\r\n    volumes[src].result += uint128(result);\r\n  }\r\n\r\n  function _doTransfers(\r\n    IERC20 src, \r\n    IERC20 dst, \r\n    uint256 amount, \r\n    uint256 minReturn, \r\n    address payable receiver,\r\n    Balances memory balances,\r\n    Fees memory fees\r\n  )\r\n    private\r\n    returns(uint256 confirmed, uint256 result, Balances memory virtualBalances)\r\n  {\r\n    uint256 _decayPeriod = getDecayPeriod();\r\n    virtualBalances.src = virtualBalanceToAdd[src].current(_decayPeriod, balances.src);\r\n    virtualBalances.src = Math.max(virtualBalances.src, balances.src);\r\n    virtualBalances.dst = virtualBalanceToRemove[dst].current(_decayPeriod, balances.dst);\r\n    virtualBalances.dst = Math.min(virtualBalances.dst, balances.dst);\r\n    src.fadTransferFrom(payable(msg.sender), address(this), amount);\r\n    confirmed = src.getBalanceOf(address(this)).sub(balances.src);\r\n    result = _getQuote(src, dst, confirmed, virtualBalances.src, virtualBalances.dst, fees.fee, fees.slippageFee);\r\n    require(result > 0 && result >= minReturn, \"Swap: Return Is Not Enough\");\r\n    dst.fadTransfer(receiver, result);\r\n\r\n    // Update virtual balances to the same direction only at imbalanced state\r\n    if(virtualBalances.src != balances.src) {\r\n      virtualBalanceToAdd[src].set(virtualBalances.src.add(confirmed));\r\n    }\r\n\r\n    if(virtualBalances.dst != balances.dst) {\r\n      virtualBalanceToRemove[dst].set(virtualBalances.dst.sub(result));\r\n    }\r\n\r\n    // Update virtual balances to the opposite direction\r\n    virtualBalanceToRemove[src].update(_decayPeriod, balances.src);\r\n    virtualBalanceToAdd[dst].update(_decayPeriod, balances.dst);\r\n  }\r\n\r\n  function _mintRewards(uint256 confirmed, uint256 result, address referral, Balances memory balances, Fees memory fees)\r\n    private \r\n  {\r\n    (\r\n      uint256 referralShare, \r\n      uint256 governanceShare, \r\n      address governanceWallet, \r\n      address feeCollector\r\n    ) = governanceFactory.getShareParameters(); \r\n\r\n    uint256 referralReward;\r\n    uint256 governanceReward;\r\n    uint256 invariantRatio = uint256(1e36);\r\n    invariantRatio = invariantRatio.mul(balances.src.add(confirmed)).div(balances.src);\r\n    invariantRatio = invariantRatio.mul(balances.dst.sub(result)).div(balances.dst);\r\n\r\n    if(invariantRatio > 1e36){\r\n      // calculate share only if invariant increased\r\n      invariantRatio = invariantRatio.sqrt();\r\n      uint256 invariantIncrease = totalSupply().mul(invariantRatio.sub(1e18)).div(invariantRatio);\r\n      \r\n      referralReward = (referral != address(0)) ? invariantIncrease.mul(referralShare).div(SwapConstants._FEE_DENOMINATOR) : 0;\r\n      governanceReward = (governanceWallet != address(0)) ? invariantIncrease.mul(governanceShare).div(SwapConstants._FEE_DENOMINATOR) : 0;\r\n\r\n      if(feeCollector == address(0)) {\r\n        if(referralReward > 0) {\r\n          _mint(referral, referralReward);\r\n        }\r\n\r\n        if(governanceReward > 0) {\r\n          _mint(governanceWallet, governanceReward);\r\n        }\r\n      } else if(referralReward > 0 || governanceReward > 0) {\r\n        uint256 length = (referralReward > 0 ? 1 : 0) + (governanceReward > 0 ? 1 : 0);\r\n        address[] memory wallets = new address[](length);\r\n        uint256[] memory rewards = new uint256[](length);\r\n\r\n        wallets[0] = referral;\r\n        rewards[0] = referralReward;\r\n        if(governanceReward > 0) {\r\n          wallets[length - 1] = governanceWallet;\r\n          rewards[length - 1] = governanceReward;\r\n        }\r\n\r\n        try IFeeCollector(feeCollector).updateRewards(wallets, rewards) {\r\n          _mint(feeCollector, referralReward.add(governanceReward));\r\n        } catch {\r\n          emit Error(\"Update Rewards Failed\");\r\n        }\r\n      }\r\n    }\r\n\r\n    emit Sync(balances.src, balances.dst, fees.fee, fees.slippageFee, referralReward, governanceReward);\r\n  }\r\n\r\n  /**\r\n    spot_ret = dx * y / x\r\n    uni_ret = dx * y / (x + dx)\r\n    slippage = (spot_ret - uni_ret) / spot_ret\r\n    slippage = dx * dx * y / (x * (x + dx)) / (dx * y / x)\r\n    slippage = dx / (x + dx)\r\n    ret = uni_ret * (1 - slip_fee * slippage)\r\n    ret = dx * y / (x + dx) * (1 - slip_fee * dx / (x + dx))\r\n    ret = dx * y / (x + dx) * (x + dx - slip_fee * dx) / (x + dx)\r\n\r\n    x = amount * denominator\r\n    dx = amount * (denominator - fee)\r\n   */\r\n  function _getQuote(\r\n    IERC20 src, \r\n    IERC20 dst,\r\n    uint256 amount,\r\n    uint256 srcBalance,\r\n    uint256 dstBalance,\r\n    uint256 fee,\r\n    uint256 slippageFee\r\n  )\r\n    internal\r\n    view\r\n    returns(uint256)\r\n  {\r\n    if(src > dst){\r\n      (src, dst) = (dst, src);\r\n    }\r\n\r\n    if(amount > 0 && src == token0 && dst == token1) {\r\n      uint256 taxedAmount = amount.sub(amount.mul(fee).div(SwapConstants._FEE_DENOMINATOR));\r\n      uint256 srcBalancePlusTaxedAmount = srcBalance.add(taxedAmount);\r\n      uint256 ret = taxedAmount.mul(dstBalance).div(srcBalancePlusTaxedAmount);\r\n      uint256 feeNumerator = SwapConstants._FEE_DENOMINATOR.mul(srcBalancePlusTaxedAmount).sub(slippageFee.mul(taxedAmount));\r\n      uint256 feeDenominator = SwapConstants._FEE_DENOMINATOR.mul(srcBalancePlusTaxedAmount);\r\n\r\n      return ret.mul(feeNumerator).div(feeDenominator);\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /** Allows contract owner to withdraw funds that was send to contract by mistake */\r\n  function rescueFunds(IERC20 token, uint256 amount)\r\n    external\r\n    nonReentrant\r\n    onlyOwner\r\n  {\r\n    uint256 balance0 = token0.getBalanceOf(address(this));\r\n    uint256 balance1 = token1.getBalanceOf(address(this));\r\n\r\n    token.fadTransfer(payable(msg.sender), amount);\r\n    require(token0.getBalanceOf(address(this)) >= balance0, \"Swap: Rescue Funds Access Denied\");\r\n    require(token1.getBalanceOf(address(this)) >= balance1, \"Swap: Rescue Funds Access Denied\");\r\n    require(balanceOf(address(this)) >= _BASE_SUPPLY, \"Swap: Rescue Funds Access Denied\");\r\n  }\r\n}"
    },
    "contracts/lib/SwapConstants.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nlibrary SwapConstants {\r\n  \r\n  uint256 internal constant _FEE_DENOMINATOR = 1e18;\r\n\r\n  uint256 internal constant _MIN_REFERRAL_SHARE = 0.05e18; // 5%\r\n  uint256 internal constant _MIN_DECAY_PERIOD = 1 minutes;\r\n\r\n  uint256 internal constant _MAX_FEE = 0.01e18; // 1%\r\n  uint256 internal constant _MAX_SLIPPAGE_FEE = 1e18; // 100%\r\n  uint256 internal constant _MAX_SHARE = 0.1e18; // 10%\r\n  uint256 internal constant _MAX_DECAY_PERIOD = 5 minutes;\r\n\r\n  uint256 internal constant _DEFAULT_FEE = 0;\r\n  uint256 internal constant _DEFAULT_SLIPPAGE_FEE = 1e18; // 100%\r\n  uint256 internal constant _DEFAULT_REFERRAL_SHARE = 0.1e18; // 10%\r\n  uint256 internal constant _DEFAULT_GOVERNANCE_SHARE = 0;\r\n  uint256 internal constant _DEFAULT_DECAY_PERIOD = 1 minutes;\r\n\r\n}"
    },
    "contracts/lib/Voting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./Vote.sol\";\r\n\r\n\r\nlibrary Voting {\r\n  using SafeMath for uint256;\r\n  using Vote for Vote.Data;\r\n\r\n  struct Data {\r\n    uint256 result;\r\n    uint256 weightedSum;\r\n    uint256 defaultVote;\r\n    mapping(address => Vote.Data) votes;\r\n  }\r\n\r\n  function updateVote(\r\n    Voting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    Vote.Data memory newVote,\r\n    uint256 balance,\r\n    uint256 totalSupply,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    return _update(self, user, oldVote, newVote, balance, balance, totalSupply, defaultVote, emitEvent);\r\n  }\r\n\r\n  function updateBalance(\r\n    Voting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    uint256 newTotalSupply,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    return _update(self, user, oldVote, newBalance == 0 ? Vote.init() : oldVote, oldBalance, newBalance, newTotalSupply, defaultVote, emitEvent);\r\n  }\r\n\r\n  function _update(\r\n    Voting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    Vote.Data memory newVote,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    uint256 totalSupply,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    uint256 oldWeightedSum = self.weightedSum;\r\n    uint256 newWeightedSum = oldWeightedSum;\r\n    uint256 oldDefaultVote = self.defaultVote;\r\n    uint256 newDefaultVote = oldDefaultVote;\r\n\r\n    if(oldVote.isDefault()) {\r\n      newDefaultVote = newDefaultVote.sub(oldBalance);\r\n    } else {\r\n      newWeightedSum = newWeightedSum.sub(oldBalance.mul(oldVote.get(defaultVote)));\r\n    }\r\n\r\n    if(newVote.isDefault()) {\r\n      newDefaultVote = newDefaultVote.add(oldBalance);\r\n    } else {\r\n      newWeightedSum = newWeightedSum.add(newBalance.mul(newVote.get(defaultVote)));\r\n    }\r\n\r\n    if(newWeightedSum != oldWeightedSum){\r\n      self.weightedSum = newWeightedSum;\r\n    }\r\n\r\n    if(newDefaultVote != oldDefaultVote){\r\n      self.defaultVote = newDefaultVote;\r\n    }\r\n\r\n    uint256 newResult = totalSupply == 0 ? defaultVote : newWeightedSum.add(newDefaultVote.mul(defaultVote)).div(totalSupply);\r\n    if(newResult != self.result){\r\n      self.result = newResult;\r\n    }\r\n\r\n    if(!newVote.eq(oldVote)){\r\n      self.votes[user] = newVote;\r\n    }\r\n\r\n    emitEvent(user, newVote.get(defaultVote), newVote.isDefault(), newBalance);\r\n  }\r\n}"
    },
    "contracts/lib/FADERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nlibrary FADERC20 {\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint256;\r\n\r\n  function isBNB(IERC20 token)\r\n    internal\r\n    pure\r\n    returns(bool)\r\n  {\r\n    return address(token) == address(0);\r\n  }\r\n\r\n  function getBalanceOf(IERC20 token, address account)\r\n    internal\r\n    view\r\n    returns(uint256)\r\n  {\r\n    if(isBNB(token)){\r\n      return account.balance;\r\n    } else {\r\n      return token.balanceOf(account);\r\n    }\r\n  }\r\n\r\n  function fadTransfer(IERC20 token, address payable to, uint256 amount) internal\r\n  {\r\n    if(amount > 0){\r\n      if(isBNB(token)){\r\n        to.transfer(amount);\r\n      } else {\r\n        token.safeTransfer(to, amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  function fadTransferFrom(IERC20 token, address payable from, address to, uint256 amount) internal\r\n  {\r\n    if(amount > 0){\r\n      if(isBNB(token)){\r\n        require(msg.value >= amount, \"Value Is not Enough\");\r\n        require(from == msg.sender, \"From Is Not The Sender\");\r\n        require(to == address(this), \"To Is Not this\");\r\n        if(msg.value > amount) {\r\n          //Return the remaining to user\r\n          from.transfer(msg.value.sub(amount));\r\n        }\r\n      } else {\r\n        token.safeTransferFrom(from, to, amount);\r\n      }\r\n    }\r\n  }\r\n\r\n  function getSymbol(IERC20 token)\r\n    internal\r\n    view\r\n    returns(string memory)\r\n  {\r\n    if(isBNB(token)){\r\n      return \"BNB\";\r\n    }\r\n\r\n    (bool success, bytes memory data) = address(token).staticcall{ gas: 20000}(\r\n      abi.encodeWithSignature(\"symbol()\")\r\n    );\r\n\r\n    if(!success){\r\n      (success, data) =  address(token).staticcall{ gas: 20000}(\r\n        abi.encodeWithSignature(\"SYMBOL()\")\r\n      );\r\n    }\r\n\r\n    if(success && data.length >= 96) {\r\n      (uint256 offset, uint256 length) = abi.decode(data, (uint256, uint256));\r\n      if(offset == 0x20 && length > 0 && length <= 256) {\r\n        return string(abi.decode(data, (bytes)));\r\n      }\r\n    }\r\n\r\n    if(success && data.length == 32) {\r\n      uint length = 0;\r\n      while (length < data.length && data[length] >= 0x20 && data[length] <= 0x7E) {\r\n        length++;\r\n      }\r\n\r\n      if(length > 0) {\r\n        bytes memory result = new bytes(length);\r\n        for(uint i = 0; i < length; i++) {\r\n          result[i] = data[i];\r\n        }\r\n        return string(result);\r\n      }\r\n    }\r\n\r\n    return _toHex(address(token));\r\n  }\r\n\r\n  function _toHex(address token)\r\n    private\r\n    pure\r\n    returns(string memory)\r\n  {\r\n    return _toHex(abi.encodePacked(token));\r\n  }\r\n\r\n  function _toHex(bytes memory data)\r\n    private\r\n    pure\r\n    returns(string memory)\r\n  {\r\n    bytes memory str = new bytes(2 + data.length * 2);\r\n    str[0] = \"0\";\r\n    str[1] = \"x\";\r\n    uint j = 2;\r\n    for(uint i = 0; i < data.length; i++) {\r\n      uint a = uint8(data[i]) >> 4;\r\n      uint b = uint8(data[i]) & 0x0f;\r\n      str[j++] = bytes1(uint8(a + 48 + (a/10) * 39));\r\n      str[j++] = bytes1(uint8(b + 48 + (b/10) * 39));\r\n    }\r\n\r\n    return string(str);\r\n  }\r\n\r\n}"
    },
    "contracts/helpers/AbstractReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./BalanceHelper.sol\";\r\n\r\n\r\n/*\r\n* Provides helper methods for token-like contracts\r\n*/\r\nabstract contract AbstractReward is Ownable, BalanceHelper {\r\n  using SafeERC20 for IERC20;\r\n  using SafeMath for uint256;\r\n\r\n  event RewardAdded(uint256 indexed position, uint256 reward);\r\n  event RewardDurationUpdated(uint256 indexed position, uint256 duration);\r\n  event RewardScaleUpdated(uint256 indexed position, uint256 scale);\r\n  event RewardPaid(uint256 indexed position, address indexed user, uint256 reward);\r\n  event RewardDistributorChanged(uint256 indexed position, address rewardDistributor);\r\n  event RewardGiftAdded(uint256 indexed position, IERC20 gift);\r\n\r\n  struct TokenReward {\r\n    IERC20 gift;\r\n    uint256 scale;\r\n    uint256 duration;\r\n    address rewardDistributor;\r\n    uint256 endDate;\r\n    uint256 rate;\r\n    uint256 lastUpdateTime;\r\n    uint256 rewardPerToken;\r\n    mapping(address => uint256) userRewardPerTokenPaid;\r\n    mapping(address => uint256) rewards;\r\n  }\r\n\r\n  TokenReward[] public tokenRewards;\r\n\r\n  modifier updateAccountReward(address account){\r\n    uint256 length = tokenRewards.length;\r\n    for(uint i = 0; i < length; i++) {\r\n      TokenReward storage tokenReward = tokenRewards[i];\r\n      uint256 newRewardPerToken = getRewardPerToken(i);\r\n      tokenReward.rewardPerToken = newRewardPerToken;\r\n      tokenReward.lastUpdateTime = getRewardLastTimeApplicable(i);\r\n      if(account != address(0)){\r\n        tokenReward.rewards[account] = _getAccountEarnedReward(i, account, newRewardPerToken);\r\n        tokenReward.userRewardPerTokenPaid[account] = newRewardPerToken;\r\n      }\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier onlyRewardDistributor(uint position) {\r\n    require(msg.sender == tokenRewards[position].rewardDistributor, \"Access Denied: Only Distributor\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * Returns current reward per token\r\n  */\r\n  function getRewardPerToken(uint position)\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    TokenReward storage tokenReward = tokenRewards[position];\r\n    if( totalSupply() == 0) {\r\n      return tokenReward.rewardPerToken;\r\n    }\r\n\r\n    return tokenReward.rewardPerToken.add(\r\n      getRewardLastTimeApplicable(position)\r\n          .sub(tokenReward.lastUpdateTime)\r\n          .mul(tokenReward.rate)\r\n          .div(totalSupply())\r\n    );\r\n  }\r\n\r\n  /** Returns last time specific token reward was applicable */\r\n  function getRewardLastTimeApplicable(uint position)\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return Math.min(block.timestamp, tokenRewards[position].endDate);\r\n  }\r\n\r\n  /** Returns how many tokens account currently has */\r\n  function getAccountEarnedReward(uint position, address account)\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _getAccountEarnedReward(position, account, getRewardPerToken(position));\r\n  }\r\n\r\n  /** Withdraws sender's reward */\r\n  function getReward(uint position)\r\n    public\r\n    updateAccountReward(msg.sender)\r\n  {\r\n    TokenReward storage tokenReward = tokenRewards[position];\r\n    uint256 reward = tokenReward.rewards[msg.sender];\r\n    if(reward > 0){\r\n      tokenReward.rewards[msg.sender] = 0;\r\n      tokenReward.gift.safeTransfer(msg.sender, reward);\r\n\r\n      emit RewardPaid(position, msg.sender, reward);\r\n    }\r\n  }\r\n\r\n  function getAllReward()\r\n    public\r\n  {\r\n    uint256 length = tokenRewards.length;\r\n    for(uint i = 0 ; i < length; i++){\r\n      getReward(i);\r\n    }\r\n  }\r\n\r\n  /** Updates specific token rewards amount */\r\n  function updateRewardAmount(uint position, uint256 reward)\r\n    external \r\n    onlyRewardDistributor(position)\r\n    updateAccountReward(address(0))\r\n  {\r\n    TokenReward storage tokenReward = tokenRewards[position];\r\n    uint256 scale = tokenReward.scale;\r\n    require(reward < type(uint).max.div(scale), \"Reward Overlow\");\r\n    uint256 duration = tokenReward.duration;\r\n    uint256 rewardRate;\r\n\r\n    if(block.timestamp >= tokenReward.endDate){\r\n      require(reward >= duration, \"Reward is too small\");\r\n      rewardRate = reward.mul(scale).div(duration);\r\n    } else {\r\n      uint256 remaining = tokenReward.endDate.sub(block.timestamp);\r\n      uint256 leftOver = remaining.mul(tokenReward.rate).div(scale);\r\n      require(reward.add(leftOver) >= duration, \"Reward is too small\");\r\n      rewardRate = reward.add(leftOver).mul(scale).div(duration);\r\n    }\r\n\r\n    uint256 balance = tokenReward.gift.balanceOf(address(this));\r\n    require(rewardRate <= balance.mul(scale).div(duration), \"Reward is too big\");\r\n    tokenReward.rate = rewardRate;\r\n    tokenReward.lastUpdateTime = block.timestamp;\r\n    tokenReward.endDate = block.timestamp.add(duration);\r\n\r\n    emit RewardAdded(position, reward);\r\n  }\r\n\r\n  /** Updates rewards distributor */\r\n  function setRewardDistributor(uint position, address rewardDistributor)\r\n    external \r\n    onlyOwner\r\n  {\r\n    TokenReward storage tokenReward = tokenRewards[position];\r\n    tokenReward.rewardDistributor = rewardDistributor;\r\n\r\n    emit RewardDistributorChanged(position, rewardDistributor);\r\n  }\r\n\r\n  /** Updates rewards duration */\r\n  function setRewardDuration(uint position, uint256 duration)\r\n    external\r\n    onlyRewardDistributor(position)\r\n  {\r\n    TokenReward storage tokenReward = tokenRewards[position];\r\n    require(block.timestamp >= tokenReward.endDate, \"Reward Not Finished Yet\");\r\n    tokenReward.duration = duration;\r\n\r\n    emit RewardDurationUpdated(position, duration);\r\n  }\r\n\r\n  /** Updates rewards scale */\r\n  function setRewardScale(uint position, uint256 scale)\r\n    external\r\n    onlyOwner\r\n  {\r\n    require(scale > 0, \"Reward Scale Too Low\");\r\n    require(scale <= 1e36, \"Reward Scale Too High\");\r\n    TokenReward storage tokenReward = tokenRewards[position];\r\n\r\n    require(tokenReward.endDate == 0, \"Can't Change Scale After Start\");\r\n    tokenReward.scale = scale;\r\n\r\n    emit RewardScaleUpdated(position, scale);\r\n  }\r\n\r\n\r\n  /** Adds new token to the list */\r\n  function addRewardGift(IERC20 gift, uint256 duration, address rewardDistributor, uint256 scale)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(scale > 0, \"Reward Scale Too Low\");\r\n    require(scale <= 1e36, \"Reward Scale Too High\");\r\n    uint256 length = tokenRewards.length;\r\n    for(uint i = 0; i < length; i++){\r\n      require(gift != tokenRewards[i].gift, \"Reward Gift Already Added\");\r\n    }\r\n\r\n    TokenReward storage tokenReward = tokenRewards.push();\r\n    tokenReward.gift = gift;\r\n    tokenReward.duration = duration;\r\n    tokenReward.scale = scale;\r\n    tokenReward.rewardDistributor = rewardDistributor;\r\n\r\n    emit RewardGiftAdded(length, gift);\r\n    emit RewardDurationUpdated(length, duration);\r\n    emit RewardDistributorChanged(length, rewardDistributor);\r\n  }\r\n  \r\n  function _getAccountEarnedReward(uint position, address account, uint256 rewardPerToken)\r\n    private\r\n    view\r\n    returns(uint256)\r\n  {\r\n    TokenReward storage tokenReward = tokenRewards[position];\r\n    return balanceOf(account)\r\n              .mul(rewardPerToken.sub(tokenReward.userRewardPerTokenPaid[account]))\r\n              .div(tokenReward.scale)\r\n              .add(tokenReward.rewards[account]); \r\n  }\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/interfaces/IFeeCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IFeeCollector {\r\n  \r\n  /** Adds specified `amount` as reward to `receiver` */\r\n  function updateReward(address receiver, uint256 amount) external;\r\n\r\n  function updateRewards(address[] calldata receivers, uint256[] calldata amounts) external;\r\n}"
    },
    "contracts/lib/SQRT.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nlibrary SQRT {\r\n  \r\n  /** https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method */\r\n  function sqrt(uint256 y) \r\n    internal\r\n    pure\r\n    returns(uint256)\r\n  {\r\n    if(y > 3) {\r\n      uint256 z = y;\r\n      uint256 x = y / 2 + 1;\r\n      while(x < z) {\r\n        z = x;\r\n        x = (y / x + x) / 2;\r\n      }\r\n      return z;\r\n    } else if (y != 0){\r\n      return 1;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n}"
    },
    "contracts/lib/VirtualBalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./SafeCast.sol\";\r\n\r\nlibrary VirtualBalance {\r\n  using SafeCast for uint256;\r\n  using SafeMath for uint256;\r\n\r\n  struct Data {\r\n    uint216 balance;\r\n    uint40 time;\r\n  }\r\n\r\n  function set(VirtualBalance.Data storage self, uint256 balance) internal {\r\n    (self.balance, self.time) = (\r\n      balance.toUint216(),\r\n      block.timestamp.toUint40()\r\n    );\r\n  }\r\n\r\n  function update(VirtualBalance.Data storage self, uint256 decayPeriod, uint256 realBalance) internal {\r\n    set(self, current(self, decayPeriod, realBalance));\r\n  }\r\n\r\n  function scale(VirtualBalance.Data storage self, uint256 decayPeriod, uint256 realBalance, uint256 num, uint256 denom) internal {\r\n    set(self, current(self, decayPeriod, realBalance).mul(num).add(denom.sub(1)).div(denom));\r\n  }\r\n\r\n  function current(VirtualBalance.Data memory self, uint256 decayPeriod, uint256 realBalance) \r\n    internal \r\n    view\r\n    returns(uint256)\r\n  {\r\n    uint256 timePassed = Math.min(decayPeriod, block.timestamp.sub(self.time));\r\n    uint256 timeRemain = decayPeriod.sub(timePassed);\r\n    return uint256(self.balance).mul(timeRemain).add(\r\n      realBalance.mul(timePassed)\r\n    ).div(decayPeriod);\r\n  }\r\n}"
    },
    "contracts/governance/Governance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"../interfaces/IGovernanceFactory.sol\";\r\nimport \"../lib/LiquidVoting.sol\";\r\nimport \"../lib/SwapConstants.sol\";\r\nimport \"../lib/SafeCast.sol\";\r\n\r\n\r\n/*\r\n* Swap governance\r\n*/\r\nabstract contract Governance is ERC20, Ownable, ReentrancyGuard {\r\n  using Vote for Vote.Data;\r\n  using LiquidVoting for LiquidVoting.Data;\r\n  using VirtualVote for VirtualVote.Data;\r\n  using SafeCast for uint256;\r\n  using SafeMath for uint256;\r\n\r\n  event FeeVoteUpdated(address indexed user, uint256 fee, bool isDefault, uint256 amount);\r\n  event SlippageFeeVoteUpdated(address indexed user, uint256 slippageFee, bool isDefault, uint256 amount);\r\n  event DecayPeriodUpdated(address indexed user, uint256 decayPeriod, bool isDefault, uint256 amount);\r\n\r\n  IGovernanceFactory public governanceFactory; \r\n  LiquidVoting.Data private _fee;\r\n  LiquidVoting.Data private _slippageFee;\r\n  LiquidVoting.Data private _decayPeriod;\r\n\r\n  constructor(IGovernanceFactory _governanceFactory)\r\n  {\r\n    governanceFactory = _governanceFactory;\r\n    _fee.data.result = _governanceFactory.getDefaultFee().toUint104();\r\n    _slippageFee.data.result = _governanceFactory.getDefaultSlippageFee().toUint104();\r\n    _decayPeriod.data.result = _governanceFactory.getDefaultDecayPeriod().toUint104();\r\n  }\r\n\r\n  function setGovernanceFactory(IGovernanceFactory _governanceFactory)\r\n    external\r\n    onlyOwner\r\n  {\r\n    governanceFactory = _governanceFactory;\r\n    this.discardFeeVote();\r\n    this.discardSlippageFeeVote();\r\n    this.discardDecayPeriodVote();\r\n  }\r\n\r\n  /** Return the current fee */\r\n  function getFee()\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _fee.data.result;\r\n  }\r\n\r\n  /** Return the current slippage fee */\r\n  function getSlippageFee()\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _slippageFee.data.result;\r\n  }\r\n\r\n  /** Return the current decay period */\r\n  function getDecayPeriod()\r\n    public\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _decayPeriod.data.result;\r\n  }\r\n\r\n  function getVirtualFee()\r\n    external\r\n    view\r\n    returns(uint104, uint104, uint48)\r\n  {\r\n    return (_fee.data.oldResult, _fee.data.result, _fee.data.time);\r\n  }\r\n\r\n  function getVirtualSlippageFee()\r\n    external\r\n    view\r\n    returns(uint104, uint104, uint48)\r\n  {\r\n    return (_slippageFee.data.oldResult, _slippageFee.data.result, _slippageFee.data.time);\r\n  }\r\n\r\n  function getVirtualDecayPeriod()\r\n    external\r\n    view\r\n    returns(uint104, uint104, uint48)\r\n  {\r\n    return (_decayPeriod.data.oldResult, _decayPeriod.data.result, _decayPeriod.data.time);\r\n  }\r\n\r\n  /** Return the user vote for the preferred fee */\r\n  function getUserFeeVote(address user)\r\n    external\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _fee.votes[user].get(governanceFactory.getDefaultFee());\r\n  }\r\n\r\n  /** Return the user vote for the preferred slippage fee */\r\n  function getUserSlippageFeeVote(address user)\r\n    external\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _slippageFee.votes[user].get(governanceFactory.getDefaultSlippageFee());\r\n  }\r\n\r\n  /** Return the user vote for the preferred decay period */\r\n  function getUserDecayPeriodVote(address user)\r\n    external\r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _decayPeriod.votes[user].get(governanceFactory.getDefaultDecayPeriod());\r\n  }\r\n\r\n  /** Records `msg.senders`'s vote for fee */\r\n  function voteFee(uint256 vote) external\r\n  {\r\n    require(vote <= SwapConstants._MAX_FEE, \"Fee Vote Is Too High\");\r\n    _fee.updateVote(\r\n      msg.sender, \r\n      _fee.votes[msg.sender], \r\n      Vote.init(vote), \r\n      balanceOf(msg.sender), \r\n      totalSupply(), \r\n      governanceFactory.getDefaultFee(), \r\n      _emitVoteFeeUpdate\r\n    );\r\n  }\r\n\r\n  /** Records `msg.senders`'s vote for slippage fee */\r\n  function voteSlippageFee(uint256 vote) external\r\n  {\r\n    require(vote <= SwapConstants._MAX_SLIPPAGE_FEE, \"Slippage Fee Vote Is Too High\");\r\n    _slippageFee.updateVote(\r\n      msg.sender, \r\n      _slippageFee.votes[msg.sender], \r\n      Vote.init(vote), \r\n      balanceOf(msg.sender), \r\n      totalSupply(), \r\n      governanceFactory.getDefaultSlippageFee(), \r\n      _emitVoteSlippageFeeUpdate\r\n    );\r\n  }\r\n\r\n  /** Records `msg.senders`'s vote for decay period */\r\n  function voteDecayPeriod(uint256 vote) external\r\n  {\r\n    require(vote <= SwapConstants._MAX_DECAY_PERIOD, \"Decay Period Vote Is Too High\");\r\n    require(vote >= SwapConstants._MIN_DECAY_PERIOD, \"Decay Period Vote Is Too Low\");\r\n    _decayPeriod.updateVote(\r\n      msg.sender, \r\n      _decayPeriod.votes[msg.sender], \r\n      Vote.init(vote), \r\n      balanceOf(msg.sender), \r\n      totalSupply(), \r\n      governanceFactory.getDefaultDecayPeriod(), \r\n      _emitVoteDecayPeriodUpdate\r\n    );\r\n  }\r\n\r\n  /** Retracts `msg.senders`'s vote for fee */\r\n  function discardFeeVote() external\r\n  {\r\n    _fee.updateVote(\r\n      msg.sender, \r\n      _fee.votes[msg.sender], \r\n      Vote.init(), \r\n      balanceOf(msg.sender), \r\n      totalSupply(), \r\n      governanceFactory.getDefaultFee(), \r\n      _emitVoteFeeUpdate\r\n    );\r\n  }\r\n\r\n  /** Retracts `msg.senders`'s vote for slippage fee */\r\n  function discardSlippageFeeVote() external\r\n  {\r\n    _slippageFee.updateVote(\r\n      msg.sender, \r\n      _slippageFee.votes[msg.sender], \r\n      Vote.init(), \r\n      balanceOf(msg.sender), \r\n      totalSupply(), \r\n      governanceFactory.getDefaultSlippageFee(), \r\n      _emitVoteSlippageFeeUpdate\r\n    );\r\n  }\r\n\r\n  /** Retracts `msg.senders`'s vote for decay period */\r\n  function discardDecayPeriodVote() external\r\n  {\r\n    _decayPeriod.updateVote(\r\n      msg.sender, \r\n      _decayPeriod.votes[msg.sender], \r\n      Vote.init(), \r\n      balanceOf(msg.sender), \r\n      totalSupply(), \r\n      governanceFactory.getDefaultDecayPeriod(), \r\n      _emitVoteDecayPeriodUpdate\r\n    );\r\n  }\r\n\r\n  function _emitVoteFeeUpdate(address user, uint256 fee, bool isDefault, uint256 amount) private\r\n  {\r\n    emit FeeVoteUpdated(user, fee, isDefault, amount);\r\n  }\r\n\r\n  function _emitVoteSlippageFeeUpdate(address user, uint256 slippageFee, bool isDefault, uint256 amount) private\r\n  {\r\n    emit SlippageFeeVoteUpdated(user, slippageFee, isDefault, amount);\r\n  }\r\n\r\n  function _emitVoteDecayPeriodUpdate(address user, uint256 decayPeriod, bool isDefault, uint256 amount) private\r\n  {\r\n    emit DecayPeriodUpdated(user, decayPeriod, isDefault, amount);\r\n  }\r\n\r\n  function _beforeTokenTransfer(address from, address to, uint256 amount)\r\n    internal\r\n    override\r\n  {\r\n    if(from == to) {\r\n      return;\r\n    }\r\n\r\n    IGovernanceFactory _governanceFactory = governanceFactory;\r\n    bool updateFrom = !(from == address(0) || _governanceFactory.isFeeCollector(from));\r\n    bool updateTo = !(to == address(0) || _governanceFactory.isFeeCollector(to));\r\n\r\n    if(!updateFrom && !updateTo) {\r\n      // mint to feeReceiver or burn from feeReceiver\r\n      return;\r\n    }\r\n\r\n    uint256 balanceFrom = (from != address(0)) ? balanceOf(from) : 0;\r\n    uint256 balanceTo = (to != address(0)) ? balanceOf(to) : 0;\r\n    uint256 newTotalSupply = totalSupply()\r\n                              .add(from == address(0) ? amount : 0)\r\n                              .sub(to == address(0) ? amount : 0);\r\n\r\n    ParamsHelper memory params = ParamsHelper({\r\n      from: from,\r\n      to: to,\r\n      updateFrom: updateFrom,\r\n      updateTo: updateTo,\r\n      amount: amount,\r\n      balanceFrom: balanceFrom,\r\n      balanceTo: balanceTo,\r\n      newTotalSupply: newTotalSupply\r\n    });\r\n\r\n    (uint256 defaultFee, uint256 defaultSlippageFee, uint256 defaultDecayPeriod) = _governanceFactory.defaults();\r\n\r\n    _updateOntransfer(params, defaultFee, _emitVoteFeeUpdate, _fee);\r\n    _updateOntransfer(params, defaultSlippageFee, _emitVoteSlippageFeeUpdate, _slippageFee);\r\n    _updateOntransfer(params, defaultDecayPeriod, _emitVoteDecayPeriodUpdate, _decayPeriod);\r\n  }\r\n\r\n  struct ParamsHelper {\r\n    address from;\r\n    address to;\r\n    bool updateFrom;\r\n    bool updateTo;\r\n    uint256 amount;\r\n    uint256 balanceFrom;\r\n    uint256 balanceTo;\r\n    uint256 newTotalSupply;\r\n  }\r\n\r\n  function _updateOntransfer(\r\n    ParamsHelper memory params, \r\n    uint256 defaultValue,\r\n    function(address, uint256, bool, uint256) internal emitEvent,\r\n    LiquidVoting.Data storage votingData\r\n  ) private\r\n  {\r\n    Vote.Data memory voteFrom = votingData.votes[params.from];\r\n    Vote.Data memory voteTo = votingData.votes[params.to];\r\n    if(voteFrom.isDefault() && voteTo.isDefault() && params.updateFrom && params.updateTo) {\r\n      emitEvent(params.from, voteFrom.get(defaultValue), true, params.balanceFrom.sub(params.amount));\r\n      emitEvent(params.to, voteTo.get(defaultValue), true, params.balanceTo.add(params.amount));\r\n      return;\r\n    }\r\n\r\n    if(params.updateFrom) {\r\n      votingData.updateBalance(\r\n        params.from, \r\n        voteFrom, \r\n        params.balanceFrom, \r\n        params.balanceFrom.sub(params.amount), \r\n        params.newTotalSupply, \r\n        defaultValue, \r\n        emitEvent\r\n      );\r\n    }\r\n\r\n    if(params.updateTo) {\r\n      votingData.updateBalance(\r\n        params.to, \r\n        voteTo, \r\n        params.balanceTo, \r\n        params.balanceTo.add(params.amount), \r\n        params.newTotalSupply, \r\n        defaultValue, \r\n        emitEvent\r\n      );\r\n    }\r\n  }\r\n\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/lib/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nlibrary SafeCast {\r\n  \r\n  function toUint216(uint256 value) \r\n    internal\r\n    pure\r\n    returns(uint216)\r\n  {\r\n    require(value < 2**216, \"value does not fit in 216 bits\");\r\n    return uint216(value);\r\n  }\r\n\r\n  function toUint104(uint256 value) \r\n    internal\r\n    pure\r\n    returns(uint104)\r\n  {\r\n    require(value < 2**104, \"value does not fit in 104 bits\");\r\n    return uint104(value);\r\n  }\r\n\r\n  function toUint48(uint256 value) \r\n    internal\r\n    pure\r\n    returns(uint48)\r\n  {\r\n    require(value < 2**48, \"value does not fit in 48 bits\");\r\n    return uint48(value);\r\n  }\r\n\r\n  function toUint40(uint256 value) \r\n    internal\r\n    pure\r\n    returns(uint40)\r\n  {\r\n    require(value < 2**40, \"value does not fit in 40 bits\");\r\n    return uint40(value);\r\n  }\r\n\r\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/interfaces/IGovernanceFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\n/** Describes methods that provide all the information about current governance contract state */\r\ninterface IGovernanceFactory {\r\n  \r\n  /** Returns information about mooniswap shares */\r\n  function getShareParameters()\r\n    external \r\n    view \r\n    returns(uint256, uint256, address, address);\r\n\r\n    /** Initial settings that contract was created */\r\n    function defaults()\r\n    external \r\n    view \r\n    returns(uint256, uint256, uint256);\r\n\r\n    /** Returns the value of default fee */\r\n    function getDefaultFee()\r\n    external \r\n    view \r\n    returns(uint256);\r\n\r\n    /** Returns the value of default slippage fee */\r\n    function getDefaultSlippageFee()\r\n    external \r\n    view \r\n    returns(uint256);\r\n\r\n    /** Returns the value of default decay period */\r\n    function getDefaultDecayPeriod()\r\n    external \r\n    view \r\n    returns(uint256);\r\n\r\n    /** Returns previous default fee that had place, \r\n    * current one and time on which this changed \r\n    */\r\n    function getVirtualDefaultFee()\r\n    external \r\n    view \r\n    returns(uint104, uint104, uint48);\r\n\r\n    /** Returns previous default slippage fee that had place, \r\n    * current one and time on which this changed \r\n    */\r\n    function getVirtualDefaultSlippageFee()\r\n    external \r\n    view \r\n    returns(uint104, uint104, uint48);\r\n\r\n    /** Returns previous default decay period that had place, \r\n    * current one and time on which this changed \r\n    */\r\n    function getVirtualDefaultDecayPeriod()\r\n    external \r\n    view \r\n    returns(uint104, uint104, uint48);\r\n\r\n    /** Returns the value of referral share */\r\n    function getReferralShare()\r\n    external \r\n    view \r\n    returns(uint256);\r\n\r\n    /** Returns the value of governance share */\r\n    function getGovernanceShare()\r\n    external \r\n    view \r\n    returns(uint256);\r\n\r\n    /** Returns the value of governance wallet address */\r\n    function governanceWallet()\r\n    external \r\n    view \r\n    returns(address);\r\n\r\n    /** Returns the value of fee collector wallet address */\r\n    function feeCollector()\r\n    external \r\n    view \r\n    returns(address);\r\n\r\n    /** Whether the address is current fee collector or was in the past. */\r\n    function isFeeCollector(address)\r\n    external \r\n    view \r\n    returns(bool);\r\n\r\n    /** Whether the contract is currently working and wasn't stopped. */\r\n    function isActive()\r\n    external \r\n    view \r\n    returns(bool);\r\n}"
    },
    "contracts/lib/LiquidVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./SafeCast.sol\";\r\nimport \"./VirtualVote.sol\";\r\nimport \"./Vote.sol\";\r\n\r\n\r\nlibrary LiquidVoting {\r\n  using SafeMath for uint256;\r\n  using SafeCast for uint256;\r\n  using Vote for Vote.Data;\r\n  using VirtualVote for VirtualVote.Data;\r\n\r\n  struct Data {\r\n    VirtualVote.Data data;\r\n    uint256 weightedSum;\r\n    uint256 defaultVote;\r\n    mapping(address => Vote.Data) votes;\r\n  }\r\n\r\n  function updateVote(\r\n    LiquidVoting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    Vote.Data memory newVote,\r\n    uint256 balance,\r\n    uint256 totalSupply,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    return _update(self, user, oldVote, newVote, balance, balance, totalSupply, defaultVote, emitEvent);\r\n  }\r\n\r\n  function updateBalance(\r\n    LiquidVoting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    uint256 newTotalSupply,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    return _update(self, user, oldVote, newBalance == 0 ? Vote.init() : oldVote, oldBalance, newBalance, newTotalSupply, defaultVote, emitEvent);\r\n  }\r\n\r\n  function _update(\r\n    LiquidVoting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    Vote.Data memory newVote,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    uint256 totalSupply,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    uint256 oldWeightedSum = self.weightedSum;\r\n    uint256 newWeightedSum = oldWeightedSum;\r\n    uint256 oldDefaultVote = self.defaultVote;\r\n    uint256 newDefaultVote = oldDefaultVote;\r\n\r\n    if(oldVote.isDefault()) {\r\n      newDefaultVote = newDefaultVote.sub(oldBalance);\r\n    } else {\r\n      newWeightedSum = newWeightedSum.sub(oldBalance.mul(oldVote.get(defaultVote)));\r\n    }\r\n\r\n    if(newVote.isDefault()) {\r\n      newDefaultVote = newDefaultVote.add(oldBalance);\r\n    } else {\r\n      newWeightedSum = newWeightedSum.add(newBalance.mul(newVote.get(defaultVote)));\r\n    }\r\n\r\n    if(newWeightedSum != oldWeightedSum){\r\n      self.weightedSum = newWeightedSum;\r\n    }\r\n\r\n    if(newDefaultVote != oldDefaultVote){\r\n      self.defaultVote = newDefaultVote;\r\n    }\r\n\r\n    {\r\n      uint256 newResult = totalSupply == 0 ? defaultVote : newWeightedSum.add(newDefaultVote.mul(defaultVote)).div(totalSupply);\r\n      VirtualVote.Data memory data = self.data;\r\n      if(newResult != data.result){\r\n        VirtualVote.Data memory sdata = self.data;\r\n        (sdata.oldResult, sdata.result, sdata.time) = (\r\n          data.current().toUint104(),\r\n          newResult.toUint104(),\r\n          block.timestamp.toUint48()\r\n        );\r\n      }\r\n    }\r\n\r\n    if(!newVote.eq(oldVote)){\r\n      self.votes[user] = newVote;\r\n    }\r\n\r\n    emitEvent(user, newVote.get(defaultVote), newVote.isDefault(), newBalance);\r\n  }\r\n}"
    },
    "contracts/lib/VirtualVote.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\n\r\nlibrary VirtualVote {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 private constant _VOTE_DECAY_PERIOD = 1 days;\r\n\r\n  struct Data {\r\n    uint104 oldResult;\r\n    uint104 result;\r\n    uint48 time;\r\n  }\r\n\r\n  function current(VirtualVote.Data memory self) \r\n    internal \r\n    view\r\n    returns(uint256)\r\n  {\r\n    uint256 timePassed = Math.min(_VOTE_DECAY_PERIOD, block.timestamp.sub(self.time));\r\n    uint256 timeRemain = _VOTE_DECAY_PERIOD.sub(timePassed);\r\n    return uint256(self.oldResult).mul(timeRemain).add(\r\n      uint256(self.result).mul(timePassed)\r\n    ).div(_VOTE_DECAY_PERIOD);\r\n  }\r\n}"
    },
    "contracts/lib/Vote.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nlibrary Vote {\r\n\r\n  uint256 private constant _VOTE_DECAY_PERIOD = 1 days;\r\n\r\n  struct Data {\r\n    uint256 value;\r\n  }\r\n\r\n  function eq(Vote.Data memory self, Vote.Data memory vote) \r\n    internal \r\n    pure\r\n    returns(bool)\r\n  {\r\n    return self.value == vote.value;\r\n  }\r\n\r\n  function init() \r\n    internal \r\n    pure\r\n    returns(Vote.Data memory data)\r\n  {\r\n    return Vote.Data({\r\n      value: 0\r\n    });\r\n  }\r\n\r\n  function init(uint256 vote) \r\n    internal \r\n    pure\r\n    returns(Vote.Data memory data)\r\n  {\r\n    return Vote.Data({\r\n      value: vote + 1\r\n    });\r\n  }\r\n\r\n  function isDefault(Data memory self) \r\n    internal \r\n    pure\r\n    returns(bool)\r\n  {\r\n    return self.value == 0;\r\n  }\r\n\r\n  function get(Data memory self, uint256 defaultVote) \r\n    internal \r\n    pure\r\n    returns(uint256)\r\n  {\r\n    if(self.value > 0){\r\n      return self.value - 1;\r\n    }\r\n\r\n    return defaultVote; \r\n  }\r\n\r\n  function get(Data memory self, function () external view returns(uint256) defaultVoteFn) \r\n    internal \r\n    view\r\n    returns(uint256)\r\n  {\r\n    if(self.value > 0){\r\n      return self.value - 1;\r\n    }\r\n\r\n    return defaultVoteFn();\r\n    \r\n  }\r\n\r\n}"
    },
    "contracts/helpers/BalanceHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\n/*\r\n* Provides helper methods for token-like contracts\r\n*/\r\ncontract BalanceHelper {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 private _totalSupply;\r\n  mapping(address => uint256) private _balances;\r\n\r\n  function totalSupply()\r\n    public \r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _totalSupply;\r\n  }\r\n\r\n  function balanceOf(address account)\r\n    public \r\n    view\r\n    returns(uint256)\r\n  {\r\n    return _balances[account];\r\n  }\r\n\r\n  function _mint(address account, uint256 amount) \r\n    internal\r\n    virtual\r\n  {\r\n    _totalSupply = _totalSupply.add(amount);\r\n    _balances[account] = _balances[account].add(amount);\r\n  }\r\n\r\n  function _burn(address account, uint256 amount) \r\n    internal\r\n    virtual\r\n  {\r\n    _balances[account] = _balances[account].sub(amount , \"Burn amount exceeds balance\");\r\n    _totalSupply = _totalSupply.sub(amount);\r\n  }\r\n\r\n  function _set(address account, uint256 amount)\r\n    internal\r\n    virtual\r\n    returns(uint256 oldAmount)\r\n  {\r\n    oldAmount = _balances[account];\r\n    if(oldAmount != amount){\r\n      _balances[account] = amount;\r\n      _totalSupply = _totalSupply.add(amount).sub(oldAmount);\r\n    }\r\n  }\r\n}"
    },
    "contracts/governance/GovernanceFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\nimport \"../interfaces/IGovernanceFactory.sol\";\r\nimport \"../lib/ExplicitLiquidVoting.sol\";\r\nimport \"../lib/SwapConstants.sol\";\r\nimport \"../lib/SafeCast.sol\";\r\nimport \"../helpers/BalanceHelper.sol\";\r\nimport \"./BaseGovernance.sol\";\r\n/*\r\n* Swap Governance Factory\r\n*/\r\ncontract GovernanceFactory is IGovernanceFactory, BaseGovernance, BalanceHelper, Ownable, Pausable {\r\n  using Vote for Vote.Data;\r\n  using ExplicitLiquidVoting for ExplicitLiquidVoting.Data;\r\n  using VirtualVote for VirtualVote.Data;\r\n  using SafeMath for uint256;\r\n  using SafeCast for uint256;\r\n\r\n  event DefaultFeeVoteUpdate(address indexed user, uint256 fee, bool isDefault, uint256 amount);\r\n  event DefaultSlippageFeeVoteUpdate(address indexed user, uint256 slippageFee, bool isDefault, uint256 amount);\r\n  event DefaultDecayPeriodVoteUpdate(address indexed user, uint256 decayPeriod, bool isDefault, uint256 amount);\r\n  event ReferralShareVoteUpdate(address indexed user, uint256 referralShare, bool isDefault, uint256 amount);\r\n  event GovernanceShareVoteUpdate(address indexed user, uint256 governanceShare, bool isDefault, uint256 amount);\r\n  event GovernanceWalletUpdate(address governanceWallet);\r\n  event FeeCollectorUpdate(address feeCollector);\r\n\r\n  ExplicitLiquidVoting.Data private _defaultFee;\r\n  ExplicitLiquidVoting.Data private _defaultSlippageFee;\r\n  ExplicitLiquidVoting.Data private _defaultDecayPeriod;\r\n  ExplicitLiquidVoting.Data private _referralShare;\r\n  ExplicitLiquidVoting.Data private _governanceShare;\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  address public override governanceWallet;\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  address public override feeCollector;\r\n\r\n  mapping(address => bool) public override isFeeCollector;\r\n\r\n  constructor(address _mothership) BaseGovernance(_mothership)\r\n  {\r\n    _defaultFee.data.result = SwapConstants._DEFAULT_FEE.toUint104();\r\n    _defaultSlippageFee.data.result = SwapConstants._DEFAULT_SLIPPAGE_FEE.toUint104();\r\n    _defaultDecayPeriod.data.result = SwapConstants._DEFAULT_DECAY_PERIOD.toUint104();\r\n    _referralShare.data.result = SwapConstants._DEFAULT_REFERRAL_SHARE.toUint104();\r\n    _governanceShare.data.result = SwapConstants._DEFAULT_GOVERNANCE_SHARE.toUint104();\r\n  }\r\n\r\n  function shutdown() external onlyOwner\r\n  {\r\n    _pause();\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function isActive()\r\n    external \r\n    view \r\n    override\r\n    returns(bool)\r\n  {\r\n    return !paused();\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getShareParameters()\r\n    external \r\n    view \r\n    override\r\n    returns(uint256, uint256, address, address)\r\n  {\r\n    return (_referralShare.data.current(), _governanceShare.data.current(), governanceWallet, feeCollector);\r\n  }  \r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function defaults()\r\n    external \r\n    view \r\n    override\r\n    returns(uint256, uint256, uint256)\r\n  {\r\n    return (_defaultFee.data.current(), _defaultSlippageFee.data.current(), _defaultDecayPeriod.data.current());\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getDefaultFee()\r\n    external \r\n    view \r\n    override\r\n    returns(uint256)\r\n  {\r\n    return _defaultFee.data.current();\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getDefaultSlippageFee()\r\n    external \r\n    view \r\n    override\r\n    returns(uint256)\r\n  {\r\n    return _defaultSlippageFee.data.current();\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getDefaultDecayPeriod()\r\n    external \r\n    view \r\n    override\r\n    returns(uint256)\r\n  {\r\n    return _defaultDecayPeriod.data.current();\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getVirtualDefaultFee()\r\n    external \r\n    view \r\n    override\r\n    returns(uint104, uint104, uint48)\r\n  {\r\n    return (_defaultFee.data.oldResult, _defaultFee.data.result, _defaultFee.data.time);\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getVirtualDefaultSlippageFee()\r\n    external \r\n    view \r\n    override\r\n    returns(uint104, uint104, uint48)\r\n  {\r\n    return (_defaultSlippageFee.data.oldResult, _defaultSlippageFee.data.result, _defaultSlippageFee.data.time);\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getVirtualDefaultDecayPeriod()\r\n    external \r\n    view \r\n    override\r\n    returns(uint104, uint104, uint48)\r\n  {\r\n    return (_defaultDecayPeriod.data.oldResult, _defaultDecayPeriod.data.result, _defaultDecayPeriod.data.time);\r\n  }\r\n\r\n  function getVirtualReferralShare()\r\n    external \r\n    view \r\n    returns(uint104, uint104, uint48)\r\n  {\r\n    return (_referralShare.data.oldResult, _referralShare.data.result, _referralShare.data.time);\r\n  }\r\n\r\n  function getVirtualGovernanceShare()\r\n    external \r\n    view \r\n    returns(uint104, uint104, uint48)\r\n  {\r\n    return (_governanceShare.data.oldResult, _governanceShare.data.result, _governanceShare.data.time);\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getReferralShare()\r\n    external \r\n    view \r\n    override\r\n    returns(uint256)\r\n  {\r\n    return _referralShare.data.current();\r\n  }\r\n\r\n  /// @inheritdoc IGovernanceFactory\r\n  function getGovernanceShare()\r\n    external \r\n    view \r\n    override\r\n    returns(uint256)\r\n  {\r\n    return _governanceShare.data.current();\r\n  }\r\n\r\n  function getDefaultFeeVotes(address user) external view returns(uint256)\r\n  {\r\n    return _defaultFee.votes[user].get(SwapConstants._DEFAULT_FEE);\r\n  }\r\n\r\n  function getDefaultSlippageFeeVotes(address user) external view returns(uint256)\r\n  {\r\n    return _defaultSlippageFee.votes[user].get(SwapConstants._DEFAULT_SLIPPAGE_FEE);\r\n  }\r\n\r\n  function getDefaultDecayPeriodVotes(address user) external view returns(uint256)\r\n  {\r\n    return _defaultDecayPeriod.votes[user].get(SwapConstants._DEFAULT_DECAY_PERIOD);\r\n  }\r\n\r\n  function getReferralShareVotes(address user) external view returns(uint256)\r\n  {\r\n    return _referralShare.votes[user].get(SwapConstants._DEFAULT_REFERRAL_SHARE);\r\n  }\r\n\r\n  function getGovernanceShareVotes(address user) external view returns(uint256)\r\n  {\r\n    return _governanceShare.votes[user].get(SwapConstants._DEFAULT_GOVERNANCE_SHARE);\r\n  }\r\n\r\n  function setGovernanceWallet(address _governanceWallet) external onlyOwner\r\n  {\r\n    governanceWallet = _governanceWallet;\r\n    emit GovernanceWalletUpdate(_governanceWallet);\r\n  }\r\n\r\n  function setFeeCollector(address _feeCollector) external onlyOwner\r\n  {\r\n    feeCollector = _feeCollector;\r\n    isFeeCollector[_feeCollector] = true;\r\n    emit FeeCollectorUpdate(_feeCollector);\r\n  }\r\n\r\n  /** Records `msg.senders`'s vote for fee */\r\n  function defaultVoteFee(uint256 vote) external\r\n  {\r\n    require(vote <= SwapConstants._MAX_FEE, \"Fee Vote Is Too High\");\r\n    _defaultFee.updateVote(\r\n      msg.sender, \r\n      _defaultFee.votes[msg.sender], \r\n      Vote.init(vote), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_FEE, \r\n      _emitDefaultVoteFeeUpdate\r\n    );\r\n  }\r\n\r\n  /** Retracts `msg.senders`'s vote for fee */\r\n  function discardDefaultFeeVote() external\r\n  {\r\n    _defaultFee.updateVote(\r\n      msg.sender, \r\n      _defaultFee.votes[msg.sender], \r\n      Vote.init(), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_FEE,\r\n      _emitDefaultVoteFeeUpdate\r\n    );\r\n  }\r\n\r\n  /** Records `msg.senders`'s vote for slippage fee */\r\n  function defaultVoteSlippageFee(uint256 vote) external\r\n  {\r\n    require(vote <= SwapConstants._MAX_SLIPPAGE_FEE, \"Slippage Fee Vote Is Too High\");\r\n    _defaultSlippageFee.updateVote(\r\n      msg.sender, \r\n      _defaultSlippageFee.votes[msg.sender], \r\n      Vote.init(vote), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_SLIPPAGE_FEE, \r\n      _emitDefaultVoteSlippageFeeUpdate\r\n    );\r\n  }\r\n\r\n  /** Retracts `msg.senders`'s vote for slippage fee */\r\n  function discardDefaultSlippageFeeVote() external\r\n  {\r\n    _defaultSlippageFee.updateVote(\r\n      msg.sender, \r\n      _defaultSlippageFee.votes[msg.sender], \r\n      Vote.init(), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_SLIPPAGE_FEE, \r\n      _emitDefaultVoteSlippageFeeUpdate\r\n    );\r\n  }\r\n\r\n  /** Records `msg.senders`'s vote for decay period */\r\n  function defaultVoteDecayPeriod(uint256 vote) external\r\n  {\r\n    require(vote <= SwapConstants._MAX_DECAY_PERIOD, \"Decay Period Vote Is Too High\");\r\n    require(vote >= SwapConstants._MIN_DECAY_PERIOD, \"Decay Period Vote Is Too Low\");\r\n    _defaultDecayPeriod.updateVote(\r\n      msg.sender, \r\n      _defaultDecayPeriod.votes[msg.sender], \r\n      Vote.init(vote), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_DECAY_PERIOD, \r\n      _emitDefaultVoteDecayPeriodUpdate\r\n    );\r\n  }\r\n\r\n  /** Retracts `msg.senders`'s vote for decay period */\r\n  function discardDefaultDecayPeriodVote() external\r\n  {\r\n    _defaultDecayPeriod.updateVote(\r\n      msg.sender, \r\n      _defaultDecayPeriod.votes[msg.sender], \r\n      Vote.init(), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_DECAY_PERIOD, \r\n      _emitDefaultVoteDecayPeriodUpdate\r\n    );\r\n  }\r\n\r\n  /** Records `msg.senders`'s vote for referral share */\r\n  function voteReferralShare(uint256 vote) external\r\n  {\r\n    require(vote <= SwapConstants._MAX_SHARE, \"Referral Share Vote Is Too High\");\r\n    require(vote >= SwapConstants._MIN_REFERRAL_SHARE, \"Referral Share Vote Is Too Low\");\r\n    _referralShare.updateVote(\r\n      msg.sender, \r\n      _referralShare.votes[msg.sender], \r\n      Vote.init(vote), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_REFERRAL_SHARE,\r\n      _emitVoteReferralShareUpdate\r\n    );\r\n  }\r\n\r\n  /** Retracts `msg.senders`'s vote for referral share */\r\n  function discardReferralShareVote() external\r\n  {\r\n    _referralShare.updateVote(\r\n      msg.sender, \r\n      _referralShare.votes[msg.sender], \r\n      Vote.init(), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_REFERRAL_SHARE,\r\n      _emitVoteReferralShareUpdate\r\n    );\r\n  }\r\n\r\n  /** Records `msg.senders`'s vote for governance share */\r\n  function voteGovernanceShare(uint256 vote) external\r\n  {\r\n    require(vote <= SwapConstants._MAX_SHARE, \"Governance Share Vote Too High\");\r\n    _governanceShare.updateVote(\r\n      msg.sender, \r\n      _governanceShare.votes[msg.sender], \r\n      Vote.init(vote), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_GOVERNANCE_SHARE,\r\n      _emitVoteGovernanceShareUpdate\r\n    );\r\n  }\r\n\r\n  /** Retracts `msg.senders`'s vote for governance share */\r\n  function discardGovernanceShareVote() external\r\n  {\r\n    _governanceShare.updateVote(\r\n      msg.sender, \r\n      _governanceShare.votes[msg.sender], \r\n      Vote.init(), \r\n      balanceOf(msg.sender), \r\n      SwapConstants._DEFAULT_GOVERNANCE_SHARE,\r\n      _emitVoteGovernanceShareUpdate\r\n    );\r\n  }\r\n\r\n  function _updateStakeChanged(address account, uint256 newBalance) internal override\r\n  {\r\n    uint256 balance = _set(account, newBalance);\r\n    if(newBalance == balance){\r\n      return;\r\n    }\r\n\r\n    _defaultFee.updateBalance(\r\n      account, \r\n      _defaultFee.votes[account], \r\n      balance, \r\n      newBalance, \r\n      SwapConstants._DEFAULT_FEE,\r\n      _emitDefaultVoteFeeUpdate\r\n    );\r\n\r\n    _defaultSlippageFee.updateBalance(\r\n      account, \r\n      _defaultSlippageFee.votes[account], \r\n      balance, \r\n      newBalance, \r\n      SwapConstants._DEFAULT_SLIPPAGE_FEE,\r\n      _emitDefaultVoteSlippageFeeUpdate\r\n    );\r\n\r\n    _defaultDecayPeriod.updateBalance(\r\n      account, \r\n      _defaultDecayPeriod.votes[account], \r\n      balance, \r\n      newBalance, \r\n      SwapConstants._DEFAULT_DECAY_PERIOD,\r\n      _emitDefaultVoteDecayPeriodUpdate\r\n    );\r\n\r\n    _referralShare.updateBalance(\r\n      account, \r\n      _referralShare.votes[account], \r\n      balance, \r\n      newBalance, \r\n      SwapConstants._DEFAULT_REFERRAL_SHARE,\r\n      _emitVoteReferralShareUpdate\r\n    );\r\n\r\n    _governanceShare.updateBalance(\r\n      account, \r\n      _governanceShare.votes[account], \r\n      balance, \r\n      newBalance, \r\n      SwapConstants._DEFAULT_GOVERNANCE_SHARE,\r\n      _emitVoteGovernanceShareUpdate\r\n    );\r\n  }\r\n\r\n  function _emitDefaultVoteFeeUpdate(address user, uint256 fee, bool isDefault, uint256 amount) private\r\n  {\r\n    emit DefaultFeeVoteUpdate(user, fee, isDefault, amount);\r\n  }\r\n\r\n  function _emitDefaultVoteSlippageFeeUpdate(address user, uint256 slippageFee, bool isDefault, uint256 amount) private\r\n  {\r\n    emit DefaultSlippageFeeVoteUpdate(user, slippageFee, isDefault, amount);\r\n  }\r\n\r\n  function _emitDefaultVoteDecayPeriodUpdate(address user, uint256 decayPeriod, bool isDefault, uint256 amount) private\r\n  {\r\n    emit DefaultDecayPeriodVoteUpdate(user, decayPeriod, isDefault, amount);\r\n  }\r\n\r\n  function _emitVoteReferralShareUpdate(address user, uint256 referralShare, bool isDefault, uint256 amount) private\r\n  {\r\n    emit ReferralShareVoteUpdate(user, referralShare, isDefault, amount);\r\n  }\r\n\r\n  function _emitVoteGovernanceShareUpdate(address user, uint256 governanceShare, bool isDefault, uint256 amount) private\r\n  {\r\n    emit GovernanceShareVoteUpdate(user, governanceShare, isDefault, amount);\r\n  }\r\n}"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/lib/ExplicitLiquidVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"./SafeCast.sol\";\r\nimport \"./VirtualVote.sol\";\r\nimport \"./Vote.sol\";\r\n\r\n\r\nlibrary ExplicitLiquidVoting {\r\n  using SafeMath for uint256;\r\n  using SafeCast for uint256;\r\n  using Vote for Vote.Data;\r\n  using VirtualVote for VirtualVote.Data;\r\n\r\n  struct Data {\r\n    VirtualVote.Data data;\r\n    uint256 weightedSum;\r\n    uint256 votedSupply;\r\n    mapping(address => Vote.Data) votes;\r\n  }\r\n\r\n  function updateVote(\r\n    ExplicitLiquidVoting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    Vote.Data memory newVote,\r\n    uint256 balance,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    return _update(self, user, oldVote, newVote, balance, balance, defaultVote, emitEvent);\r\n  }\r\n\r\n  function updateBalance(\r\n    ExplicitLiquidVoting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    return _update(self, user, oldVote, newBalance == 0 ? Vote.init() : oldVote, oldBalance, newBalance, defaultVote, emitEvent);\r\n  }\r\n\r\n  function _update(\r\n    ExplicitLiquidVoting.Data storage self,\r\n    address user,\r\n    Vote.Data memory oldVote,\r\n    Vote.Data memory newVote,\r\n    uint256 oldBalance,\r\n    uint256 newBalance,\r\n    uint256 defaultVote,\r\n    function(address, uint256, bool, uint256) emitEvent\r\n  ) internal {\r\n    uint256 oldWeightedSum = self.weightedSum;\r\n    uint256 newWeightedSum = oldWeightedSum;\r\n    uint256 oldVotedSupply = self.votedSupply;\r\n    uint256 newVotedSupply = oldVotedSupply;\r\n\r\n    if(!oldVote.isDefault()) {\r\n      newWeightedSum = newWeightedSum.sub(oldBalance.mul(oldVote.get(defaultVote)));\r\n      newVotedSupply = newVotedSupply.sub(oldBalance);\r\n    }\r\n\r\n    if(!newVote.isDefault()) {\r\n      newWeightedSum = newWeightedSum.add(newBalance.mul(newVote.get(defaultVote)));\r\n      newVotedSupply = newVotedSupply.add(newBalance);\r\n    }\r\n\r\n    if(newWeightedSum != oldWeightedSum){\r\n      self.weightedSum = newWeightedSum;\r\n    }\r\n\r\n    if(newVotedSupply != oldVotedSupply){\r\n      self.votedSupply = newVotedSupply;\r\n    }\r\n\r\n    {\r\n      uint256 newResult = newVotedSupply == 0 ? defaultVote : newWeightedSum.div(newVotedSupply);\r\n      VirtualVote.Data memory data = self.data;\r\n      if(newResult != data.result){\r\n        VirtualVote.Data memory sdata = self.data;\r\n        (sdata.oldResult, sdata.result, sdata.time) = (\r\n          data.current().toUint104(),\r\n          newResult.toUint104(),\r\n          block.timestamp.toUint48()\r\n        );\r\n      }\r\n    }\r\n\r\n    if(!newVote.eq(oldVote)){\r\n      self.votes[user] = newVote;\r\n    }\r\n\r\n    emitEvent(user, newVote.get(defaultVote), newVote.isDefault(), newBalance);\r\n  }\r\n}"
    },
    "contracts/governance/BaseGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../interfaces/IGovernance.sol\";\r\n\r\n\r\n/*\r\n* Base governance contract with notification logics\r\n*/\r\nabstract contract BaseGovernance is IGovernance {\r\n  address public immutable mothership;\r\n\r\n  modifier onlyMothership {\r\n    require(msg.sender == mothership, \"Access Restricted To Mothership\");\r\n    _;\r\n  }\r\n\r\n  constructor(address _mothership) {\r\n    mothership = _mothership;\r\n  }\r\n\r\n\r\n  function updateStakeChanged(address account, uint256 newBalance) external override onlyMothership\r\n  {\r\n    _updateStakeChanged(account, newBalance);\r\n  }\r\n\r\n  function updateStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) \r\n    external\r\n    override \r\n    onlyMothership\r\n  {\r\n    require(accounts.length == newBalances.length, \"Array Length Invalid\");\r\n    for(uint256 i = 0; i < accounts.length; i++) {\r\n      _updateStakeChanged(accounts[i], newBalances[i]);\r\n    }\r\n  }\r\n\r\n  function _updateStakeChanged(address account, uint256 newBalance) internal virtual; \r\n}"
    },
    "contracts/interfaces/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IGovernance {\r\n  function updateStakeChanged(address account, uint256 newBalance) external;\r\n  function updateStakesChanged(address[] calldata accounts, uint256[] calldata newBalances) external;\r\n}"
    },
    "contracts/SwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./interfaces/IPoolCreator.sol\";\r\nimport \"./interfaces/ISwapFactory.sol\";\r\nimport \"./lib/FADERC20.sol\";\r\nimport \"./Swap.sol\";\r\nimport \"./governance/GovernanceFactory.sol\";\r\n\r\n\r\n/*\r\n* contract for maintaining tokens whitelist\r\n*/\r\ncontract SwapFactory is ISwapFactory, GovernanceFactory {\r\n  using FADERC20 for IERC20;\r\n\r\n  event Deployed(\r\n    Swap indexed swap,\r\n    IERC20 indexed token1,\r\n    IERC20 indexed token2\r\n  );\r\n\r\n  IPoolCreator public immutable poolCreator;\r\n  address public immutable poolOwner;\r\n  Swap[] public allPools;\r\n  mapping(Swap => bool) public override isPool; \r\n  mapping(IERC20 => mapping(IERC20 => Swap)) private _pools; \r\n\r\n  constructor(address _poolOwner, IPoolCreator _poolCreator, address _governanceMothership)\r\n    GovernanceFactory(_governanceMothership)\r\n  {\r\n    poolOwner = _poolOwner;\r\n    poolCreator = _poolCreator;\r\n  }\r\n\r\n  function getAllPools() external view returns(Swap[] memory)\r\n  {\r\n    return allPools;\r\n  }\r\n\r\n  /// @inheritdoc ISwapFactory\r\n  function pools(IERC20 tokenA, IERC20 tokenB) external view override returns(Swap pool)\r\n  {\r\n    (IERC20 token1, IERC20 token2) = sortTokens(tokenA, tokenB);\r\n    return _pools[token1][token2];\r\n  }\r\n\r\n  function deploy(\r\n    IERC20 tokenA,\r\n    IERC20 tokenB\r\n  )\r\n    public returns(Swap pool)\r\n  {\r\n    require(tokenA != tokenB, \"SwapFactory: Duplicate Tokens\");\r\n    (IERC20 token1, IERC20 token2) = sortTokens(tokenA, tokenB);\r\n    require(_pools[token1][token2] == Swap(address(0)), \"SwapFactory: Pool Already Exists\");\r\n\r\n    string memory symbole1 = token1.getSymbol();\r\n    string memory symbole2 = token2.getSymbol();\r\n\r\n    pool = poolCreator.deploy(\r\n      token1, \r\n      token2, \r\n      string(abi.encodePacked(\"Liquidity Pool (\", symbole1, \"-\", symbole2, \")\")), \r\n      string(abi.encodePacked(symbole1, \"-\", symbole2, \"-LP\")), \r\n      poolOwner\r\n    );\r\n\r\n    _pools[token1][token2] = pool;\r\n    allPools.push(pool);\r\n    isPool[pool] = true;\r\n\r\n    emit Deployed(pool, token1, token2);\r\n  }\r\n\r\n  function sortTokens(IERC20 token1, IERC20 token2) public pure returns(IERC20, IERC20)\r\n  {\r\n    if(token1 < token2) {\r\n      return (token1, token2);\r\n    }\r\n\r\n    return (token2, token1);\r\n  }\r\n}"
    },
    "contracts/interfaces/IPoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../Swap.sol\";\r\n\r\n/** deploying token pair pools */\r\ninterface IPoolCreator {\r\n\r\n  function deploy(\r\n    IERC20 token1,\r\n    IERC20 token2,\r\n    string calldata name,\r\n    string calldata symbol,\r\n    address poolOwner\r\n  )\r\n  external returns(Swap pool);\r\n}"
    },
    "contracts/interfaces/ISwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"../Swap.sol\";\r\n\r\ninterface ISwapFactory is IGovernanceFactory{\r\n  \r\n  /** Returns a pool for tokens pair. \r\n  * Zero address result means that pool doesn't exist yet \r\n  */\r\n  function pools(IERC20 token0, IERC20 token1) external view returns(Swap);\r\n\r\n  /** If address is currently listed as a swap pool. Otherwise, false */\r\n  function isPool(Swap swap) external view returns(bool);\r\n}"
    },
    "contracts/PoolCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"./Swap.sol\";\r\n\r\n/** Helper contract to deploy pools */\r\ncontract PoolCreator {\r\n  \r\n  function deploy(\r\n    IERC20 token1,\r\n    IERC20 token2,\r\n    string calldata name,\r\n    string calldata symbol,\r\n    address poolOwner\r\n  ) external returns(Swap pool)\r\n  {\r\n    pool = new Swap(token1, token2, name, symbol, IGovernanceFactory(msg.sender));\r\n    pool.transferOwnership(poolOwner);\r\n  } \r\n}"
    },
    "contracts/helpers/Converter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../interfaces/ISwapFactory.sol\";\r\nimport \"../lib/FADERC20.sol\";\r\nimport \"../lib/VirtualBalance.sol\";\r\nimport \"../Swap.sol\";\r\n\r\n\r\n/*\r\n* Base contract for maintaining tokens whitelist\r\n*/\r\nabstract contract Converter is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n  using FADERC20 for IERC20;\r\n  using VirtualBalance for VirtualBalance.Data;\r\n\r\n  uint256 private constant _ONE = 1e18;\r\n  uint256 private constant _MAX_SPREAD = 0.01e18;\r\n  uint256 private constant _MAX_LIQUIDITY_SHARE = 100;\r\n  IERC20 public immutable fadToken;\r\n  ISwapFactory public immutable swapFactory;\r\n  mapping(IERC20 => bool) public pathWhitlist;\r\n\r\n  constructor(IERC20 _fadToken, ISwapFactory _swapFactory) {\r\n    fadToken = _fadToken;\r\n    swapFactory = _swapFactory;\r\n  }\r\n\r\n  receive() external payable {\r\n    require(msg.sender != tx.origin, \"Transfer forbidden\");\r\n  }\r\n\r\n  modifier validSpread(Swap swap){\r\n    require(_validateSpread(swap), \"Spread Is Too High\");\r\n    _;\r\n  }\r\n\r\n  modifier validPool(Swap swap){\r\n    require(swapFactory.isPool(swap), \"Invalid pool\");\r\n    _;\r\n  }\r\n\r\n  modifier validPath(IERC20[] memory path){\r\n    require(path.length > 0, \"Min Path Length Is 1\");\r\n    require(path.length < 5, \"Max Path Length Is 4\");\r\n    require(path[path.length - 1] == fadToken, \"Should Swap To Target Token\");\r\n\r\n    for(uint256 i = 0; i < path.length; i += 1){\r\n      require(pathWhitlist[path[i]], \"Token Is Not Whitelist\");\r\n    }\r\n    _;\r\n  }\r\n\r\n  function updatePathWhitelist(IERC20 token, bool status)\r\n    external\r\n    onlyOwner\r\n  {\r\n    pathWhitlist[token] = status;\r\n  }\r\n\r\n  function _validateSpread(Swap swap)\r\n    internal\r\n    view\r\n    returns(bool)\r\n  {\r\n    IERC20[] memory tokens = swap.getTokens();\r\n    uint256 buyPrice;\r\n    uint256 sellPrice;\r\n    uint256 spotPrice;\r\n    {\r\n      uint256 token0Balance = tokens[0].getBalanceOf(address(swap));\r\n      uint256 token1Balance = tokens[1].getBalanceOf(address(swap));\r\n      uint256 decayPeriod = swap.getDecayPeriod();\r\n      VirtualBalance.Data memory vb; \r\n      (vb.balance, vb.time) = swap.virtualBalanceToAdd(tokens[0]);\r\n      uint256 token0BalanceToAdd = Math.max(vb.current(decayPeriod, token0Balance), token0Balance);\r\n      (vb.balance, vb.time) = swap.virtualBalanceToAdd(tokens[1]);\r\n      uint256 token1BalanceToAdd = Math.max(vb.current(decayPeriod, token1Balance), token1Balance);\r\n      (vb.balance, vb.time) = swap.virtualBalanceToRemove(tokens[0]);\r\n      uint256 token0BalanceToRemove = Math.min(vb.current(decayPeriod, token0Balance), token0Balance);\r\n      (vb.balance, vb.time) = swap.virtualBalanceToRemove(tokens[1]);\r\n      uint256 token1BalanceToRemove = Math.min(vb.current(decayPeriod, token1Balance), token1Balance);\r\n\r\n      buyPrice = _ONE.mul(token1BalanceToAdd).div(token0BalanceToRemove);\r\n      sellPrice = _ONE.mul(token1BalanceToRemove).div(token0BalanceToAdd);\r\n      spotPrice = _ONE.mul(token1Balance).div(token0Balance);\r\n    }\r\n\r\n    return buyPrice.sub(sellPrice).mul(_ONE) < _MAX_SPREAD.mul(spotPrice);\r\n  }\r\n\r\n  function _getMaxAmountForSwap(IERC20[] memory path, uint256 amount)\r\n    internal\r\n    view\r\n    returns(uint256 srcAmount, uint256 dstAmount)\r\n  {\r\n    srcAmount = amount;\r\n    dstAmount = amount;\r\n    uint256 pathLength = path.length;\r\n    for(uint256 i = 0 ; i < pathLength; i += 1) {\r\n      Swap swap = swapFactory.pools(path[i], path[i+1]);\r\n      uint256 maxCurrentStepAmount = path[i].getBalanceOf(address(swap)).div(_MAX_LIQUIDITY_SHARE);\r\n      if(maxCurrentStepAmount < dstAmount) {\r\n        srcAmount = srcAmount.mul(maxCurrentStepAmount).div(dstAmount);\r\n        dstAmount = maxCurrentStepAmount;\r\n      }\r\n      dstAmount = swap.getQuote(path[i], path[i+1], dstAmount);\r\n    }\r\n  }\r\n\r\n  function _swap(IERC20[] memory path, uint256 initialAmount, address payable destination)\r\n    internal\r\n    returns(uint256 amount)\r\n  {\r\n    amount = initialAmount;\r\n    uint256 pathLength = path.length;\r\n    for(uint256 i = 0 ; i < pathLength; i += 1) {\r\n      Swap swap = swapFactory.pools(path[i], path[i+1]);\r\n      require(_validateSpread(swap), \"Spread Is Too High\");\r\n      uint256 value = amount;\r\n      if(!path[i].isBNB()){\r\n        path[i].safeApprove(address(swap), amount);\r\n        value = 0;\r\n      }\r\n\r\n      if(i + 2 < pathLength) {\r\n        amount = swap.swap{value: value}(path[i], path[i+1], amount, 0, address(0));\r\n      } else {\r\n        amount = swap.swapFor{value: value}(path[i], path[i+1], amount, 0, address(0), destination);\r\n      }\r\n    }\r\n\r\n    if(pathLength == 1) {\r\n      path[0].transfer(destination, amount);\r\n    }\r\n  }\r\n}"
    },
    "contracts/ReferralFeeReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"./interfaces/IFeeCollector.sol\";\r\nimport \"./lib/FADERC20.sol\";\r\nimport \"./helpers/Converter.sol\";\r\n\r\n/*\r\n* The Referral Fee Collector\r\n*/\r\ncontract ReferralFeeReceiver is IFeeCollector, Converter, ReentrancyGuard {\r\n  using FADERC20 for IERC20;\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for IERC20;\r\n\r\n  struct UserInfo {\r\n    uint256 balance;\r\n    mapping(IERC20 => mapping(uint256 => uint256)) share;\r\n    mapping(IERC20 => uint256) firstUnprocessedEpoch;\r\n  }\r\n\r\n  struct EpochBalance {\r\n    uint256 totalSupply;\r\n    uint256 token0Balance;\r\n    uint256 token1Balance;\r\n    uint256 fadBalance;\r\n  }\r\n\r\n  struct TokenInfo {\r\n    mapping(uint256 => EpochBalance) epochBalance;\r\n    uint256 firstUnprocessedEpoch;\r\n    uint256 currentEpoch;\r\n  }\r\n\r\n  mapping(address => UserInfo) public userInfo;\r\n  mapping(IERC20 => TokenInfo) public tokenInfo;\r\n\r\n  constructor(IERC20 fadToken, ISwapFactory _swapFactory) Converter(fadToken, _swapFactory){}\r\n\r\n  /// @inheritdoc IFeeCollector\r\n  function updateRewards(address[] calldata receivers, uint256[] calldata amounts) external override\r\n  {\r\n    for(uint i = 0; i < receivers.length; i++) {\r\n      updateReward(receivers[i], amounts[i]);\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IFeeCollector\r\n  function updateReward(address referral, uint256 amount) public override\r\n  {\r\n    Swap swap = Swap(msg.sender);\r\n    TokenInfo storage token = tokenInfo[swap];\r\n    UserInfo storage user = userInfo[referral];\r\n    uint256 currentEpoch = token.currentEpoch;\r\n\r\n    // Add new reward to current epoch\r\n    user.share[swap][currentEpoch] = user.share[swap][currentEpoch].add(amount);\r\n    token.epochBalance[currentEpoch].totalSupply = token.epochBalance[currentEpoch].totalSupply.add(amount);\r\n\r\n    // Collect all processed epochs and advance user token epoch\r\n    _collectProcessedEpochs(user, token, swap, currentEpoch);\r\n  }\r\n\r\n  /** Freezes current epoch and creates new as an active one */\r\n  function freezeEpoch(Swap swap) external nonReentrant validPool(swap) validSpread(swap) \r\n  {\r\n    TokenInfo storage token = tokenInfo[swap];\r\n    uint256 currentEpoch = token.currentEpoch;\r\n    require(token.firstUnprocessedEpoch == currentEpoch, \"Previous Epoch Is Not Finalized\");\r\n    IERC20[] memory tokens = swap.getTokens();\r\n    uint256 token0Balance = tokens[0].getBalanceOf(address(this));\r\n    uint256 token1Balance = tokens[1].getBalanceOf(address(this));\r\n    swap.withdraw(swap.balanceOf(address(this)), new uint256[](0));\r\n    token.epochBalance[currentEpoch].token0Balance = tokens[0].getBalanceOf(address(this)).sub(token0Balance);\r\n    token.epochBalance[currentEpoch].token1Balance = tokens[1].getBalanceOf(address(this)).sub(token1Balance);\r\n    token.currentEpoch = token.currentEpoch.add(1);\r\n  }\r\n\r\n  /** Perform chain swap described by `path`. First element of `path` should match either token of the `Swap`.\r\n  * The last token in chain should always be `FAD` \r\n  */\r\n  function trade(Swap swap, IERC20[] memory path) external nonReentrant validPool(swap) validSpread(swap)\r\n  {\r\n    TokenInfo storage token = tokenInfo[swap];\r\n    uint256 firstUnprocessedEpoch = token.firstUnprocessedEpoch;\r\n    EpochBalance storage epochBalance = token.epochBalance[firstUnprocessedEpoch];\r\n    require(firstUnprocessedEpoch.add(1) == token.currentEpoch, \"Previous Epoch Already Finalized\");\r\n    IERC20[] memory tokens = swap.getTokens();\r\n    uint256 availableBalance;\r\n    if(path[0] == tokens[0]) {\r\n      availableBalance = epochBalance.token0Balance;\r\n    } else if(path[0] == tokens[1]) {\r\n      availableBalance = epochBalance.token1Balance;\r\n    } else {\r\n      revert(\"Invalid first token\");\r\n    }\r\n\r\n    (uint256 amount, uint256 returnAmount) = _getMaxAmountForSwap(path, availableBalance);\r\n    if(returnAmount == 0) {\r\n      // get rid of dust\r\n      if(availableBalance > 0) {\r\n        require(availableBalance == amount, \"Available Balance Is Not Dust\");\r\n        for(uint256 i = 0; i + 1 < path.length; i += 1) {\r\n          Swap _swap = swapFactory.pools(path[i], path[i + 1]);\r\n          require(_validateSpread(_swap), \"Spread Is Too Hight\");\r\n        }\r\n\r\n        if(path[0].isBNB()){\r\n          payable(tx.origin).transfer(availableBalance);\r\n        } else {\r\n          path[0].safeTransfer(address(swap), availableBalance);\r\n        }\r\n      }\r\n    } else {\r\n      uint256 receivedAmount = _swap(path, amount, payable(address(this)));\r\n      epochBalance.fadBalance = epochBalance.fadBalance.add(receivedAmount);\r\n    }\r\n\r\n    if(path[0] == tokens[0]) {\r\n      epochBalance.token0Balance = epochBalance.token0Balance.sub(amount);\r\n    } else if(path[0] == tokens[1]) {\r\n      epochBalance.token1Balance = epochBalance.token1Balance.sub(amount);\r\n    }\r\n\r\n    if(epochBalance.token0Balance == 0 && epochBalance.token1Balance == 0) {\r\n      token.firstUnprocessedEpoch = token.firstUnprocessedEpoch.add(1);\r\n    }\r\n  }\r\n\r\n  /** Collects `msg.sender`'s tokens from pools and transfers them to him */\r\n  function claim(Swap[] memory pools) external {\r\n    UserInfo storage user = userInfo[msg.sender];\r\n    for(uint256 i = 0; i < pools.length; i++) {\r\n      Swap swap = pools[i];\r\n      TokenInfo storage token = tokenInfo[swap];\r\n      _collectProcessedEpochs(user, token, swap, token.currentEpoch);\r\n    }\r\n\r\n    uint256 balance = user.balance;\r\n    if(balance > 1) {\r\n      // Avoid erasing storage to decrease gas footprint for referral payments\r\n      user.balance = 1;\r\n      fadToken.transfer(msg.sender, balance - 1);\r\n    }\r\n  }\r\n\r\n  /** Collects current epoch `msg.sender`'s tokens from pool and transfers them to him */\r\n  function claimCurrentEpoch(Swap swap) external nonReentrant validPool(swap) {\r\n    UserInfo storage user = userInfo[msg.sender];\r\n    TokenInfo storage token = tokenInfo[swap];\r\n    uint256 currentEpoch = token.currentEpoch;\r\n    uint256 balance = user.share[swap][currentEpoch];\r\n    if(balance > 0) {\r\n      user.share[swap][currentEpoch] = 0;\r\n      token.epochBalance[currentEpoch].totalSupply = token.epochBalance[currentEpoch].totalSupply.sub(balance);\r\n      swap.transfer(msg.sender, balance);\r\n    }\r\n  }\r\n\r\n  /** Collects frozen epoch `msg.sender`'s tokens from pool and transfers them to him */\r\n  function claimFrozenEpoch(Swap swap) external nonReentrant validPool(swap) {\r\n    UserInfo storage user = userInfo[msg.sender];\r\n    TokenInfo storage token = tokenInfo[swap];\r\n    uint256 currentEpock = token.currentEpoch;\r\n    uint256 firstUnprocessedEpoch = token.firstUnprocessedEpoch;\r\n    require(firstUnprocessedEpoch.add(1) == token.currentEpoch, \"Epoch Already Finalized\");\r\n    require(user.firstUnprocessedEpoch[swap] == firstUnprocessedEpoch, \"Epoch Funds Alreaded Claimed\");\r\n    user.firstUnprocessedEpoch[swap] = currentEpock;\r\n    uint256 share = user.share[swap][firstUnprocessedEpoch];\r\n    if(share > 0) {\r\n      EpochBalance storage epochBalance = token.epochBalance[firstUnprocessedEpoch];\r\n      uint256 totalSupply = epochBalance.totalSupply;\r\n      user.share[swap][firstUnprocessedEpoch] = 0;\r\n      epochBalance.totalSupply = totalSupply.sub(share);\r\n\r\n      IERC20[] memory tokens = swap.getTokens();\r\n      epochBalance.token0Balance = _transferTokenShare(tokens[0], epochBalance.token0Balance, share, totalSupply);\r\n      epochBalance.token1Balance = _transferTokenShare(tokens[1], epochBalance.token1Balance, share, totalSupply);\r\n      epochBalance.fadBalance = _transferTokenShare(fadToken, epochBalance.fadBalance, share, totalSupply);\r\n    }\r\n  }\r\n\r\n  function _transferTokenShare(IERC20 token, uint256 balance, uint256 share, uint256 totalSupply) \r\n    private \r\n    returns(uint256 newBalance)\r\n  {\r\n    uint256 amount = balance.mul(share).div(totalSupply);\r\n    if(amount > 0) {\r\n      token.fadTransfer(payable(msg.sender), amount);\r\n    }\r\n\r\n    return balance.sub(amount);\r\n  }\r\n\r\n  function _collectProcessedEpochs(UserInfo storage user, TokenInfo storage token, Swap swap, uint256 currentEpoch) private\r\n  {\r\n    uint256 userEpoch = user.firstUnprocessedEpoch[swap];\r\n\r\n    // Early return for the new users\r\n    if(user.share[swap][userEpoch] == 0) {\r\n      user.firstUnprocessedEpoch[swap] = currentEpoch;\r\n      return;\r\n    }\r\n\r\n    uint256 tokenEpoch = token.firstUnprocessedEpoch;\r\n    if(tokenEpoch <= userEpoch) {\r\n      return;\r\n    }\r\n\r\n    uint256 epochCount = Math.min(2, tokenEpoch - userEpoch); // 0, 1 or 2 epochs\r\n\r\n    // Claim 1 or 2 processed epochs for the user\r\n    uint256 collected = _collectEpoch(user, token, swap, userEpoch);\r\n    if(epochCount > 1) {\r\n      collected = collected.add(_collectEpoch(user, token, swap, userEpoch + 1));\r\n    }\r\n\r\n    user.balance = user.balance.add(collected);\r\n\r\n    // Update user token epoch counter\r\n    bool emptySecondEpoch = user.share[swap][userEpoch + 1] == 0;\r\n    user.firstUnprocessedEpoch[swap] = (epochCount == 2 || emptySecondEpoch) ? currentEpoch : userEpoch + 1;\r\n  }\r\n\r\n  function _collectEpoch(UserInfo storage user, TokenInfo storage token, Swap swap, uint256 epoch) \r\n    private\r\n    returns(uint256 collected)\r\n  {\r\n    uint256 share = user.share[swap][epoch];\r\n    if(share > 0) {\r\n      uint256 fabBalance = token.epochBalance[epoch].fadBalance;\r\n      uint256 totalSupply = token.epochBalance[epoch].totalSupply;\r\n\r\n      collected = fabBalance.mul(share).div(totalSupply);\r\n      user.share[swap][epoch] = 0;\r\n      token.epochBalance[epoch].totalSupply = totalSupply.sub(share);\r\n      token.epochBalance[epoch].fadBalance = fabBalance.sub(collected);\r\n    }\r\n  }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}